# HG changeset patch
# User Lars T Hansen <lhansen@mozilla.com>
# Date 1499384022 25200
#      Thu Jul 06 16:33:42 2017 -0700
# Node ID 5fdb05cbbc6139a018a813712c1b1c6841f53c35
# Parent  02b9376bea86bd86e86d1747509e6660af545928
Baldrdash compilation framework

diff --git a/.hgignore b/.hgignore
--- a/.hgignore
+++ b/.hgignore
@@ -39,6 +39,7 @@
 _DBG\.OBJ/
 _OPT\.OBJ/
 ^js/src/.*-obj/
+^js/src/baldrdash/target
 
 # SpiderMonkey configury
 ^js/src/configure$
diff --git a/js/moz.configure b/js/moz.configure
--- a/js/moz.configure
+++ b/js/moz.configure
@@ -255,3 +255,9 @@ with only_when('--enable-compile-environ
 
     set_config('LIBFUZZER', enable_libfuzzer)
     set_define('LIBFUZZER', enable_libfuzzer)
+
+# Rust
+# ==============================================================
+include('../build/moz.configure/rust.configure',
+        when='--enable-compile-environment')
+
diff --git a/js/src/baldrdash/Cargo.toml b/js/src/baldrdash/Cargo.toml
new file mode 100644
--- /dev/null
+++ b/js/src/baldrdash/Cargo.toml
@@ -0,0 +1,29 @@
+[package]
+name = "baldrdash"
+version = "0.1.0"
+authors = ["Lars T Hansen <lth@acm.org>"]
+
+[lib]
+name = "baldrdash"
+crate-type = ["staticlib"]
+
+[profile.release]
+opt-level = 3
+debug = false
+rpath = false
+lto = false
+debug-assertions = false
+# codegen-units ignored with lto=true
+codegen-units = 4
+panic = "abort"
+
+[profile.dev]
+opt-level = 0
+debug = true
+rpath = false
+lto = false
+debug-assertions = true
+codegen-units = 4
+panic = "abort"
+
+[dependencies]
diff --git a/js/src/baldrdash/Makefile b/js/src/baldrdash/Makefile
new file mode 100644
--- /dev/null
+++ b/js/src/baldrdash/Makefile
@@ -0,0 +1,33 @@
+src/baldrapi.rs: baldrapi.h Makefile
+	bindgen \
+	--whitelist-type ConstantValue \
+	--whitelist-type Emitter \
+	--whitelist-type ExprType \
+	--whitelist-type FuncBytes \
+	--whitelist-type GlobalDesc \
+	--whitelist-type MemoryUsage \
+	--whitelist-type ModuleEnvironment \
+	--whitelist-type ModuleKind \
+	--whitelist-type Sig \
+	--whitelist-type SigWithId \
+	--whitelist-type SigIdDesc \
+	--whitelist-type SigIdDescKind \
+	--whitelist-type TableDesc \
+	--whitelist-type ValType \
+	--whitelist-type WasmContext \
+	--whitelist-function 'cx_.*' \
+	--whitelist-function 'emitter_.*' \
+	--whitelist-function 'env_.*' \
+	--whitelist-function 'funcBytes_.*' \
+	--whitelist-function 'global_.*' \
+	--whitelist-function 'sig_.*' \
+	--whitelist-function 'sigWithId_.*' \
+	--whitelist-function 'sigIdDesc_.*' \
+	baldrapi.h | \
+	sed -e s/ExprType_//g \
+	    -e s/MemoryUsage_//g \
+	    -e s/ModuleKind_//g \
+	    -e s/SigIdDescKind_//g \
+	    -e s/ValType_//g \
+	    -e s/BD_//g \
+	> src/baldrapi.rs
diff --git a/js/src/baldrdash/baldrapi.h b/js/src/baldrdash/baldrapi.h
new file mode 100644
--- /dev/null
+++ b/js/src/baldrdash/baldrapi.h
@@ -0,0 +1,169 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ * vim: set ts=8 sts=4 et sw=4 tw=99:
+ *
+ * Copyright 2017 Mozilla Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// This is an ADT-style C API to the WebAssembly per-function compilation state,
+// allowing Rust to access constant metadata and produce output.
+//
+// The Rust code must export a single function as follows:
+//
+//    extern "C" bool wasm_compile_function(const WasmContext* context)
+//
+// and then call accessors on the context to obtain input and output data
+// structures.  The return value is true on success, false on OOM; there should
+// be no other errors, as the bytecode will already have been validated before
+// this call.
+
+// This file is input to Rust's bindgen, so as to create primitive APIs for the
+// Cretonne pipeline to access compilation metadata.  The output of bindgen is
+// postprocessed to remove all the BD_ prefixes and to remove the redundant type
+// name prefixes in the enums (eg, ValType::ValType_I32 becomes just
+// ValType::I32).  See Makefile in this directory for more.
+//
+// The actual Rust API then wraps these primitive APIs.  See src/baldrdash.rs.
+//
+// This file can be included in SpiderMonkey's C++ code, where all the prefixes
+// must be obeyed.  The purpose of the prefixes is to avoid type confusion.  See
+// js/src/wasm/WasmCretonneCompile.cpp.
+
+// DO NOT USE C++ IN THIS FILE.
+// DO NOT INCLUDE SPIDERMONKEY HEADER FILES INTO THIS FILE.
+
+#include <stdbool.h>
+#include <inttypes.h>
+
+// wasm/*.{cpp,h}, class and struct types that are opaque to us here
+
+typedef struct BD_Emitter BD_Emitter;
+typedef struct BD_FuncBytes BD_FuncBytes;
+typedef struct BD_GlobalDesc BD_GlobalDesc;
+typedef struct BD_ModuleEnvironment BD_ModuleEnvironment;
+typedef struct BD_Sig BD_Sig;
+typedef struct BD_SigIdDesc BD_SigIdDesc;
+typedef struct BD_SigWithId BD_SigWithId;
+typedef struct BD_TableDesc BD_TableDesc;
+typedef struct BD_WasmContext BD_WasmContext;
+
+// wasm/WasmTypes.h: enum class ExprType
+
+typedef enum
+{
+    ExprType_Void = 0x40,
+
+    ExprType_I32 = 0x7f,
+    ExprType_I64 = 0x7e,
+    ExprType_F32 = 0x7d,
+    ExprType_F64 = 0x7c
+} BD_ExprType;
+
+// wasm/WasmCode.h: enum class MemoryUsage
+
+typedef enum
+{
+    MemoryUsage_None = 0,
+    MemoryUsage_Unshared = 1,
+    MemoryUsage_Shared = 2
+} BD_MemoryUsage;
+
+// wasm/WasmTypes.h: enum ModuleKind
+
+typedef enum
+{
+    ModuleKind_Wasm = 0,
+    ModuleKind_AsmJS = 1
+} BD_ModuleKind;
+
+// wasm/WasmTypes.h: enum class Kind within class SigIdDesc
+
+typedef enum
+{
+    SigIdDescKind_None = 0,
+    SigIdDescKind_Immediate = 1,
+    SigIdDescKind_Global = 2
+} BD_SigIdDescKind;
+
+// wasm/WasmBinaryConstants.h: enum class ValType
+
+typedef enum
+{
+    ValType_I32 = 0x7f,
+    ValType_I64 = 0x7e,
+    ValType_F32 = 0x7d,
+    ValType_F64 = 0x7c
+} BD_ValType;
+
+// Possible constant values for initializing globals
+
+typedef struct
+{
+    BD_ValType t;
+    union {
+	int32_t i32;
+	int64_t i64;
+	float f32;
+	double f64;
+    } u;
+} BD_ConstantValue;
+
+const BD_ModuleEnvironment* cx_environment(const BD_WasmContext*);
+const BD_FuncBytes* cx_funcBytes(const BD_WasmContext*);
+bool cx_debugEnabled(const BD_WasmContext*);
+const BD_Emitter* cx_emitter(const BD_WasmContext*);
+
+// appendBytes returns false on OOM, otherwise true
+bool emitter_appendBytes(const BD_Emitter*, const uint8_t* begin, uint32_t count);
+void emitter_setBeginOffset(const BD_Emitter*, uint32_t offset);
+void emitter_setEndOffset(const BD_Emitter*, uint32_t offset);
+void emitter_setRetOffset(const BD_Emitter*, uint32_t offset);
+void emitter_setNormalEntryOffset(const BD_Emitter*, uint32_t offset);
+
+// TODO: There will be more emitter methods, to set up metainformation such as
+// addresses of heap accesses, and patch points.
+
+BD_ModuleKind env_kind(const BD_ModuleEnvironment*);
+const BD_Sig* env_functionSignature(const BD_ModuleEnvironment*, uint32_t funcIndex);
+uint32_t env_funcImportGlobalDataOffset(const BD_ModuleEnvironment*, uint32_t funcIndex);
+bool env_funcIsImport(const BD_ModuleEnvironment*, uint32_t funcIndex);
+const BD_SigWithId* env_signature(const BD_ModuleEnvironment*, uint32_t sigIndex);
+uint32_t env_numTables(const BD_ModuleEnvironment*);
+const BD_TableDesc* env_table(const BD_ModuleEnvironment*, uint32_t tableIndex);
+const BD_GlobalDesc* env_global(const BD_ModuleEnvironment*, uint32_t globalIndex);
+uint32_t env_minMemoryLength(const BD_ModuleEnvironment*);
+bool env_hasMaxMemoryLength(const BD_ModuleEnvironment*);
+uint32_t env_maxMemoryLength(const BD_ModuleEnvironment*);
+BD_MemoryUsage env_memoryUsage(const BD_ModuleEnvironment*);
+
+const uint8_t* funcBytes_bytes(const BD_FuncBytes*);
+uint32_t funcBytes_numBytes(const BD_FuncBytes*);
+uint32_t funcBytes_lineOrBytecode(const BD_FuncBytes*);
+const BD_SigWithId* funcBytes_sig(const BD_FuncBytes*);
+uint32_t funcBytes_index(const BD_FuncBytes*);
+const uint32_t* funcBytes_callSiteLineNums(const BD_FuncBytes*);
+uint32_t funcBytes_numCallSiteLineNums(const BD_FuncBytes*);
+
+bool global_isConstant(const BD_GlobalDesc*);
+BD_ConstantValue global_constantValue(const BD_GlobalDesc*);
+BD_ValType global_type(const BD_GlobalDesc*);
+
+uint32_t sig_numArgs(const BD_Sig*);
+const BD_ValType* sig_args(const BD_Sig*);
+BD_ValType sig_argType(const BD_Sig*, uint32_t argIndex);
+BD_ExprType sig_retType(const BD_Sig*);
+
+const BD_SigIdDesc* sigWithId_idDesc(const BD_SigWithId*);
+
+BD_SigIdDescKind sigIdDesc_kind(const BD_SigIdDesc*);
diff --git a/js/src/baldrdash/moz.build b/js/src/baldrdash/moz.build
new file mode 100644
--- /dev/null
+++ b/js/src/baldrdash/moz.build
@@ -0,0 +1,7 @@
+# -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
+# vim: set filetype=python:
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+RustLibrary('baldrdash')
diff --git a/js/src/baldrdash/src/baldrapi.rs b/js/src/baldrdash/src/baldrapi.rs
new file mode 100644
--- /dev/null
+++ b/js/src/baldrdash/src/baldrapi.rs
@@ -0,0 +1,300 @@
+/* automatically generated by rust-bindgen */
+
+#[repr(C)]
+pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
+impl <T> __BindgenUnionField<T> {
+    #[inline]
+    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
+    #[inline]
+    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
+    #[inline]
+    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
+}
+impl <T> ::std::default::Default for __BindgenUnionField<T> {
+    #[inline]
+    fn default() -> Self { Self::new() }
+}
+impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
+    #[inline]
+    fn clone(&self) -> Self { Self::new() }
+}
+impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
+impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
+    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
+        fmt.write_str("__BindgenUnionField")
+    }
+}
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct Emitter {
+    _unused: [u8; 0],
+}
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct FuncBytes {
+    _unused: [u8; 0],
+}
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct GlobalDesc {
+    _unused: [u8; 0],
+}
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct ModuleEnvironment {
+    _unused: [u8; 0],
+}
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct Sig {
+    _unused: [u8; 0],
+}
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct SigIdDesc {
+    _unused: [u8; 0],
+}
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct SigWithId {
+    _unused: [u8; 0],
+}
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct TableDesc {
+    _unused: [u8; 0],
+}
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct WasmContext {
+    _unused: [u8; 0],
+}
+#[repr(u32)]
+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
+pub enum ExprType {
+    Void = 64,
+    I32 = 127,
+    I64 = 126,
+    F32 = 125,
+    F64 = 124,
+}
+#[repr(u32)]
+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
+pub enum MemoryUsage {
+    None = 0,
+    Unshared = 1,
+    Shared = 2,
+}
+#[repr(u32)]
+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
+pub enum ModuleKind { Wasm = 0, AsmJS = 1, }
+#[repr(u32)]
+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
+pub enum SigIdDescKind {
+    None = 0,
+    Immediate = 1,
+    Global = 2,
+}
+#[repr(u32)]
+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
+pub enum ValType {
+    I32 = 127,
+    I64 = 126,
+    F32 = 125,
+    F64 = 124,
+}
+#[repr(C)]
+#[derive(Debug, Copy)]
+pub struct ConstantValue {
+    pub t: ValType,
+    pub u: ConstantValue__bindgen_ty_1,
+}
+#[repr(C)]
+#[derive(Debug, Copy)]
+pub struct ConstantValue__bindgen_ty_1 {
+    pub i32: __BindgenUnionField<i32>,
+    pub i64: __BindgenUnionField<i64>,
+    pub f32: __BindgenUnionField<f32>,
+    pub f64: __BindgenUnionField<f64>,
+    pub bindgen_union_field: u64,
+}
+#[test]
+fn bindgen_test_layout_ConstantValue__bindgen_ty_1() {
+    assert_eq!(::std::mem::size_of::<ConstantValue__bindgen_ty_1>() ,
+               8usize , concat ! (
+               "Size of: " , stringify ! ( ConstantValue__bindgen_ty_1 )
+               ));
+    assert_eq! (::std::mem::align_of::<ConstantValue__bindgen_ty_1>() ,
+                8usize , concat ! (
+                "Alignment of " , stringify ! ( ConstantValue__bindgen_ty_1
+                ) ));
+    assert_eq! (unsafe {
+                & ( * ( 0 as * const ConstantValue__bindgen_ty_1 ) ) . i32
+                as * const _ as usize } , 0usize , concat ! (
+                "Alignment of field: " , stringify ! (
+                ConstantValue__bindgen_ty_1 ) , "::" , stringify ! ( i32 )
+                ));
+    assert_eq! (unsafe {
+                & ( * ( 0 as * const ConstantValue__bindgen_ty_1 ) ) . i64
+                as * const _ as usize } , 0usize , concat ! (
+                "Alignment of field: " , stringify ! (
+                ConstantValue__bindgen_ty_1 ) , "::" , stringify ! ( i64 )
+                ));
+    assert_eq! (unsafe {
+                & ( * ( 0 as * const ConstantValue__bindgen_ty_1 ) ) . f32
+                as * const _ as usize } , 0usize , concat ! (
+                "Alignment of field: " , stringify ! (
+                ConstantValue__bindgen_ty_1 ) , "::" , stringify ! ( f32 )
+                ));
+    assert_eq! (unsafe {
+                & ( * ( 0 as * const ConstantValue__bindgen_ty_1 ) ) . f64
+                as * const _ as usize } , 0usize , concat ! (
+                "Alignment of field: " , stringify ! (
+                ConstantValue__bindgen_ty_1 ) , "::" , stringify ! ( f64 )
+                ));
+}
+impl Clone for ConstantValue__bindgen_ty_1 {
+    fn clone(&self) -> Self { *self }
+}
+#[test]
+fn bindgen_test_layout_ConstantValue() {
+    assert_eq!(::std::mem::size_of::<ConstantValue>() , 16usize , concat !
+               ( "Size of: " , stringify ! ( ConstantValue ) ));
+    assert_eq! (::std::mem::align_of::<ConstantValue>() , 8usize , concat !
+                ( "Alignment of " , stringify ! ( ConstantValue ) ));
+    assert_eq! (unsafe {
+                & ( * ( 0 as * const ConstantValue ) ) . t as * const _ as
+                usize } , 0usize , concat ! (
+                "Alignment of field: " , stringify ! ( ConstantValue ) ,
+                "::" , stringify ! ( t ) ));
+    assert_eq! (unsafe {
+                & ( * ( 0 as * const ConstantValue ) ) . u as * const _ as
+                usize } , 8usize , concat ! (
+                "Alignment of field: " , stringify ! ( ConstantValue ) ,
+                "::" , stringify ! ( u ) ));
+}
+impl Clone for ConstantValue {
+    fn clone(&self) -> Self { *self }
+}
+extern "C" {
+    pub fn cx_environment(arg1: *const WasmContext)
+     -> *const ModuleEnvironment;
+}
+extern "C" {
+    pub fn cx_funcBytes(arg1: *const WasmContext) -> *const FuncBytes;
+}
+extern "C" {
+    pub fn cx_debugEnabled(arg1: *const WasmContext) -> bool;
+}
+extern "C" {
+    pub fn cx_emitter(arg1: *const WasmContext) -> *const Emitter;
+}
+extern "C" {
+    pub fn emitter_appendBytes(arg1: *const Emitter, begin: *const u8,
+                               count: u32) -> bool;
+}
+extern "C" {
+    pub fn emitter_setBeginOffset(arg1: *const Emitter, offset: u32);
+}
+extern "C" {
+    pub fn emitter_setEndOffset(arg1: *const Emitter, offset: u32);
+}
+extern "C" {
+    pub fn emitter_setRetOffset(arg1: *const Emitter, offset: u32);
+}
+extern "C" {
+    pub fn emitter_setNormalEntryOffset(arg1: *const Emitter, offset: u32);
+}
+extern "C" {
+    pub fn env_kind(arg1: *const ModuleEnvironment) -> ModuleKind;
+}
+extern "C" {
+    pub fn env_functionSignature(arg1: *const ModuleEnvironment,
+                                 funcIndex: u32) -> *const Sig;
+}
+extern "C" {
+    pub fn env_funcImportGlobalDataOffset(arg1: *const ModuleEnvironment,
+                                          funcIndex: u32) -> u32;
+}
+extern "C" {
+    pub fn env_funcIsImport(arg1: *const ModuleEnvironment, funcIndex: u32)
+     -> bool;
+}
+extern "C" {
+    pub fn env_signature(arg1: *const ModuleEnvironment, sigIndex: u32)
+     -> *const SigWithId;
+}
+extern "C" {
+    pub fn env_numTables(arg1: *const ModuleEnvironment) -> u32;
+}
+extern "C" {
+    pub fn env_table(arg1: *const ModuleEnvironment, tableIndex: u32)
+     -> *const TableDesc;
+}
+extern "C" {
+    pub fn env_global(arg1: *const ModuleEnvironment, globalIndex: u32)
+     -> *const GlobalDesc;
+}
+extern "C" {
+    pub fn env_minMemoryLength(arg1: *const ModuleEnvironment) -> u32;
+}
+extern "C" {
+    pub fn env_hasMaxMemoryLength(arg1: *const ModuleEnvironment) -> bool;
+}
+extern "C" {
+    pub fn env_maxMemoryLength(arg1: *const ModuleEnvironment) -> u32;
+}
+extern "C" {
+    pub fn env_memoryUsage(arg1: *const ModuleEnvironment)
+     -> MemoryUsage;
+}
+extern "C" {
+    pub fn funcBytes_bytes(arg1: *const FuncBytes) -> *const u8;
+}
+extern "C" {
+    pub fn funcBytes_numBytes(arg1: *const FuncBytes) -> u32;
+}
+extern "C" {
+    pub fn funcBytes_lineOrBytecode(arg1: *const FuncBytes) -> u32;
+}
+extern "C" {
+    pub fn funcBytes_sig(arg1: *const FuncBytes) -> *const SigWithId;
+}
+extern "C" {
+    pub fn funcBytes_index(arg1: *const FuncBytes) -> u32;
+}
+extern "C" {
+    pub fn funcBytes_callSiteLineNums(arg1: *const FuncBytes)
+     -> *const u32;
+}
+extern "C" {
+    pub fn funcBytes_numCallSiteLineNums(arg1: *const FuncBytes) -> u32;
+}
+extern "C" {
+    pub fn global_isConstant(arg1: *const GlobalDesc) -> bool;
+}
+extern "C" {
+    pub fn global_constantValue(arg1: *const GlobalDesc)
+     -> ConstantValue;
+}
+extern "C" {
+    pub fn global_type(arg1: *const GlobalDesc) -> ValType;
+}
+extern "C" {
+    pub fn sig_numArgs(arg1: *const Sig) -> u32;
+}
+extern "C" {
+    pub fn sig_args(arg1: *const Sig) -> *const ValType;
+}
+extern "C" {
+    pub fn sig_argType(arg1: *const Sig, argIndex: u32) -> ValType;
+}
+extern "C" {
+    pub fn sig_retType(arg1: *const Sig) -> ExprType;
+}
+extern "C" {
+    pub fn sigWithId_idDesc(arg1: *const SigWithId) -> *const SigIdDesc;
+}
+extern "C" {
+    pub fn sigIdDesc_kind(arg1: *const SigIdDesc) -> SigIdDescKind;
+}
diff --git a/js/src/baldrdash/src/baldrdash.rs b/js/src/baldrdash/src/baldrdash.rs
new file mode 100644
--- /dev/null
+++ b/js/src/baldrdash/src/baldrdash.rs
@@ -0,0 +1,244 @@
+/* Copyright 2017 Mozilla Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Safe wrappers to the low-level ABI.  This re-exports all types in
+// baldrapi but none of the functions.
+
+// TODO: Should many u32 arguments and return values here really be
+// usize, to be more conventional?
+//
+// TODO: No methods here on TableDesc, surely a bug.
+
+use std::slice;
+
+use baldrapi;
+
+pub use baldrapi::ExprType;
+pub use baldrapi::MemoryUsage;
+pub use baldrapi::ModuleKind;
+pub use baldrapi::SigIdDescKind;
+pub use baldrapi::ValType;
+
+pub enum ConstantValue {
+    I32(i32),
+    I64(i64),
+    F32(f32),
+    F64(f64)
+}
+
+pub struct Emitter ( *const baldrapi::Emitter );
+pub struct FuncBytes ( *const baldrapi::FuncBytes );
+pub struct GlobalDesc ( *const baldrapi::GlobalDesc );
+pub struct ModuleEnvironment ( *const baldrapi::ModuleEnvironment );
+pub struct Sig ( *const baldrapi::Sig );
+pub struct SigIdDesc ( *const baldrapi::SigIdDesc );
+pub struct SigWithId ( *const baldrapi::SigWithId );
+pub struct TableDesc ( *const baldrapi::TableDesc );
+pub struct WasmContext ( *const baldrapi::WasmContext );
+
+impl Emitter
+{
+    pub fn append_bytes(&self, bytes: &[u8]) -> Result<(),()> {
+        match unsafe { baldrapi::emitter_appendBytes(self.0,
+                                                     bytes.as_ptr(),
+                                                     bytes.len() as u32) }
+        {
+            true => Ok(()),
+            false => Err(())
+        }
+    }
+
+    pub fn set_begin_offset(&self, offset: u32) {
+        unsafe { baldrapi::emitter_setBeginOffset(self.0, offset) }
+    }
+
+    pub fn set_end_offset(&self, offset: u32) {
+        unsafe { baldrapi::emitter_setEndOffset(self.0, offset) }
+    }
+
+    pub fn set_ret_offset(&self, offset: u32) {
+        unsafe { baldrapi::emitter_setRetOffset(self.0, offset) }
+    }
+
+    pub fn set_normal_entry_offset(&self, offset: u32) {
+        unsafe { baldrapi::emitter_setNormalEntryOffset(self.0, offset) }
+    }
+}
+
+impl FuncBytes
+{
+    pub fn bytes<'a>(&self) -> &'a [u8] {
+        unsafe {
+            slice::from_raw_parts(baldrapi::funcBytes_bytes(self.0),
+                                  baldrapi::funcBytes_numBytes(self.0) as usize)
+        }
+    }
+
+    pub fn line_or_bytecode(&self) -> u32 {
+        unsafe { baldrapi::funcBytes_lineOrBytecode(self.0) }
+    }
+
+    pub fn sig(&self) -> SigWithId {
+        SigWithId(unsafe { baldrapi::funcBytes_sig(self.0) })
+    }
+
+    pub fn index(&self) -> u32 {
+        unsafe { baldrapi::funcBytes_index(self.0) }
+    }
+
+    pub fn call_site_line_nums<'a>(&self) -> &'a [u32] {
+        unsafe {
+            slice::from_raw_parts(baldrapi::funcBytes_callSiteLineNums(self.0),
+                                  baldrapi::funcBytes_numCallSiteLineNums(self.0) as usize)
+        }
+    }
+}
+
+impl GlobalDesc
+{
+    pub fn the_type(&self) -> ValType {
+        unsafe { baldrapi::global_type(self.0) }
+    }
+
+    pub fn constant_value(&self) -> Option<ConstantValue> {
+        unsafe {
+            if !baldrapi::global_isConstant(self.0) {
+                return None
+            }
+            let v = baldrapi::global_constantValue(self.0);
+            match v.t {
+                ValType::I32 => Some(ConstantValue::I32(*v.u.i32.as_ref())),
+                ValType::I64 => Some(ConstantValue::I64(*v.u.i64.as_ref())),
+                ValType::F32 => Some(ConstantValue::F32(*v.u.f32.as_ref())),
+                ValType::F64 => Some(ConstantValue::F64(*v.u.f64.as_ref()))
+            }
+        }
+    }
+}
+
+impl ModuleEnvironment
+{
+    pub fn kind(&self) -> ModuleKind {
+        unsafe { baldrapi::env_kind(self.0) }
+    }
+
+    pub fn function_signature(&self, func_index:u32) -> Sig {
+        Sig(unsafe { baldrapi::env_functionSignature(self.0, func_index) })
+    }
+
+    pub fn func_is_import(&self, func_index:u32) -> bool {
+        unsafe { baldrapi::env_funcIsImport(self.0, func_index) }
+    }
+
+    pub fn func_import_global_data_offset(&self, func_index:u32) -> u32 {
+        unsafe { baldrapi::env_funcImportGlobalDataOffset(self.0, func_index) }
+    }
+
+    pub fn signature(&self, sig_index:u32) -> SigWithId {
+        SigWithId(unsafe { baldrapi::env_signature(self.0, sig_index) })
+    }
+
+    pub fn num_tables(&self) -> u32 {
+        unsafe { baldrapi::env_numTables(self.0) }
+    }
+
+    pub fn table(&self, table_index:u32) -> TableDesc {
+        TableDesc(unsafe { baldrapi::env_table(self.0, table_index) })
+    }
+
+    pub fn global(&self, global_index:u32) -> GlobalDesc {
+        GlobalDesc(unsafe { baldrapi::env_global(self.0, global_index) })
+    }
+
+    pub fn min_memory_length(&self) -> u32 {
+        unsafe { baldrapi::env_minMemoryLength(self.0) }
+    }
+
+    pub fn max_memory_length(&self) -> Option<u32> {
+        unsafe {
+            if baldrapi::env_hasMaxMemoryLength(self.0) {
+                Some(baldrapi::env_maxMemoryLength(self.0))
+            } else {
+                None
+            }
+        }
+    }
+
+    pub fn memory_usage(&self) -> MemoryUsage {
+        unsafe { baldrapi::env_memoryUsage(self.0) }
+    }
+}
+
+impl Sig
+{
+    pub fn num_args(&self) -> u32 {
+        unsafe { baldrapi::sig_numArgs(self.0) }
+    }
+
+    pub fn args<'a>(&self) -> &'a [ValType] {
+        unsafe {
+            slice::from_raw_parts(baldrapi::sig_args(self.0),
+                                  baldrapi::sig_numArgs(self.0) as usize)
+        }
+    }
+
+    // TODO: Do we really need this?  It's here because the C++ wasm compilers
+    // use it, but it could be gotten by going via args().
+    pub fn arg_type(&self, arg_index: u32) -> ValType {
+        unsafe { baldrapi::sig_argType(self.0, arg_index) }
+    }
+
+    pub fn ret_type(&self) -> ExprType {
+        unsafe { baldrapi::sig_retType(self.0) }
+    }
+}
+
+impl SigIdDesc
+{
+    pub fn kind(&self) -> SigIdDescKind {
+        unsafe { baldrapi::sigIdDesc_kind(self.0) }
+    }
+}
+
+impl SigWithId
+{
+    pub fn id_desc(&self) -> SigIdDesc {
+        SigIdDesc(unsafe { baldrapi::sigWithId_idDesc(self.0) })
+    }
+}
+
+impl WasmContext
+{
+    pub fn new(p: *const baldrapi::WasmContext) -> WasmContext {
+        WasmContext(p)
+    }
+
+    pub fn environment(&self) -> ModuleEnvironment {
+        ModuleEnvironment(unsafe { baldrapi::cx_environment(self.0) })
+    }
+
+    pub fn func_bytes(&self) -> FuncBytes {
+        FuncBytes(unsafe { baldrapi::cx_funcBytes(self.0) })
+    }
+
+    pub fn debug_enabled(&self) -> bool {
+        unsafe { baldrapi::cx_debugEnabled(self.0) }
+    }
+
+    pub fn emitter(&self) -> Emitter {
+        Emitter(unsafe { baldrapi::cx_emitter(self.0) })
+    }
+}
+
diff --git a/js/src/baldrdash/src/cretin.rs b/js/src/baldrdash/src/cretin.rs
new file mode 100644
--- /dev/null
+++ b/js/src/baldrdash/src/cretin.rs
@@ -0,0 +1,121 @@
+/* Copyright 2017 Mozilla Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// A really stupid wasm compiler, for testing baldrdash.
+
+// Test:
+//
+// Run the JS shell with --wasm-always-cretonne and then at the command prompt do this:
+//
+// js> var ins = new WebAssembly.Instance(new WebAssembly.Module(wasmTextToBinary('(module (func (result i32) (i32.const 0xdeadbeef)) (export "" 0))')))
+// js> (ins.exports[""]()>>>0).toString(16)
+//
+// It should print "deadbeef".  No other programs are allowed, though you can choose a different constant.
+// This only works on x86 and x64, for now.
+
+use baldrdash::*;
+
+pub type Res = Result<(),()>;
+
+pub fn compile(cx:WasmContext) -> Res {
+    let mut emitter = cx.emitter();
+    let mut offs = 0;
+
+    emitter.set_begin_offset(offs);            // Begin offset before anything
+
+    // Prologue(s)
+
+    emitter.set_normal_entry_offset(offs);     // Normal-entry offset after the profiling prologue
+
+    // A completely ad-hoc parser.  There must be no parameters or
+    // locals; the function's body must be a single i32 expression;
+    // there must be no explicit return.
+
+    let func = cx.func_bytes();
+    let bytes = func.bytes();
+    let input = 0;
+
+    // DecodeLocalEntries
+    let (num_locals, input) = read_var_u32(bytes, input);
+    assert!(num_locals == 0, "Number of locals");
+
+    const END      : u32 = 0x0B;
+    const I32CONST : u32 = 0x41;
+
+    // Body
+
+    let (op, input) = read_op(bytes, input);
+    let input = if op == I32CONST {
+        let (val, input) = read_var_i32(bytes, input);
+        let mut code = vec![0xB8];             // MOV eax, imm32
+        let mut v = val as u32;
+        for i in 0..4 {
+            code.push((v & 255) as u8);
+            v = v >> 8;
+        }
+        try!(emitter.append_bytes(&code));
+        offs += code.len() as u32;
+        input
+    } else {
+        panic!("Unexpected opcode: expected i32const")
+    };
+
+    let (op, input) = read_op(bytes, input);
+    if op == END {
+        assert!(input as usize == bytes.len(), "Number of operations");
+    } else {
+        panic!("Unexpected opcode: expected end");
+    }
+
+    // Return
+
+    emitter.set_ret_offset(offs);              // Return offset right before return instruction
+    let ret = [0xC3];                          // RET
+    try!(emitter.append_bytes(&ret));
+    offs += ret.len() as u32;
+
+    emitter.set_end_offset(offs);              // End offset after everything
+
+    Ok(())
+}
+
+fn read_op(bytes:&[u8], loc:u32) -> (u32, u32) {
+    let v = bytes[loc as usize];
+    let loc = loc + 1;
+    (v as u32, loc)
+}
+
+fn read_var_u32(bytes:&[u8], loc:u32) -> (u32, u32) {
+    let v = bytes[loc as usize];
+    let loc = loc + 1;
+    assert!(v < 127);
+    (v as u32, loc)
+}
+
+fn read_var_i32(bytes:&[u8], mut loc:u32) -> (i32, u32) {
+    let mut value: u32 = 0;
+    let mut i = 0;
+    loop {
+        let v = bytes[loc as usize] as u32;
+        loc += 1;
+        value = value | ((v & 127) << i);
+        i += 7;
+        println!("{}", v);
+        if v <= 127 {
+            break;
+        }
+    }
+    (value as i32, loc)
+}
diff --git a/js/src/baldrdash/src/lib.rs b/js/src/baldrdash/src/lib.rs
new file mode 100644
--- /dev/null
+++ b/js/src/baldrdash/src/lib.rs
@@ -0,0 +1,37 @@
+/* Copyright 2017 Mozilla Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// For testing, see instructions in cretin.rs.
+
+#![allow(unused)]
+#![warn(unused_must_use)]
+
+mod baldrapi;                   // Low-level C API, ignore this
+mod baldrdash;                  // High-level Rust API, use this
+mod cretin;                     // Example usages
+
+// This main program should basically remain unused, its only function
+// is to wrap up the C WasmContext into a Rust datum and call the
+// compiler proper.  Change the compile() function you call to use a
+// different compiler.
+
+#[no_mangle]
+pub extern fn wasm_compile_function(cx:*const baldrapi::WasmContext) -> bool {
+    match cretin::compile(baldrdash::WasmContext::new(cx)) {
+        Ok(_) => true,
+        Err(_) => false
+    }
+}
+
diff --git a/js/src/build/moz.build b/js/src/build/moz.build
--- a/js/src/build/moz.build
+++ b/js/src/build/moz.build
@@ -43,6 +43,7 @@ if CONFIG['ENABLE_INTL_API']:
         ]
 
 USE_LIBS += [
+    'baldrdash',
     'nspr',
     'zlib',
 ]
diff --git a/js/src/gdb/moz.build b/js/src/gdb/moz.build
--- a/js/src/gdb/moz.build
+++ b/js/src/gdb/moz.build
@@ -34,6 +34,8 @@ USE_LIBS += [
     'static:js',
 ]
 
+USE_LIBS += [ 'baldrdash' ]
+
 if CONFIG['ENABLE_INTL_API'] and CONFIG['MOZ_ICU_DATA_ARCHIVE']:
     # The ICU libraries linked into libmozjs will not include the ICU data,
     # so link it directly.
diff --git a/js/src/jit/x86-shared/Assembler-x86-shared.h b/js/src/jit/x86-shared/Assembler-x86-shared.h
--- a/js/src/jit/x86-shared/Assembler-x86-shared.h
+++ b/js/src/jit/x86-shared/Assembler-x86-shared.h
@@ -419,6 +419,11 @@ class AssemblerX86Shared : public Assemb
             return false;
         return masm.appendBuffer(other.masm);
     }
+    MOZ_MUST_USE bool
+    appendBytes(const uint8_t* bytes, size_t numbytes)
+    {
+        return masm.appendBytes(bytes, numbytes);
+    }
     void processCodeLabels(uint8_t* rawCode);
     void copyJumpRelocationTable(uint8_t* dest);
     void copyDataRelocationTable(uint8_t* dest);
diff --git a/js/src/jit/x86-shared/BaseAssembler-x86-shared.h b/js/src/jit/x86-shared/BaseAssembler-x86-shared.h
--- a/js/src/jit/x86-shared/BaseAssembler-x86-shared.h
+++ b/js/src/jit/x86-shared/BaseAssembler-x86-shared.h
@@ -3879,6 +3879,10 @@ threeByteOpImmSimd("vblendps", VEX_PD, O
         bool ret = m_formatter.append(buf, other.size());
         return ret;
     }
+    MOZ_MUST_USE bool appendBytes(const uint8_t* bytes, size_t numbytes)
+    {
+        return m_formatter.append(bytes, numbytes);
+    }
 
   protected:
     static bool CAN_SIGN_EXTEND_8_32(int32_t value) { return value == (int32_t)(int8_t)value; }
diff --git a/js/src/jsapi-tests/moz.build b/js/src/jsapi-tests/moz.build
--- a/js/src/jsapi-tests/moz.build
+++ b/js/src/jsapi-tests/moz.build
@@ -145,6 +145,8 @@ USE_LIBS += [
     'static:js',
 ]
 
+USE_LIBS += [ 'baldrdash' ]
+
 OS_LIBS += CONFIG['MOZ_ZLIB_LIBS']
 
 if CONFIG['GNU_CXX']:
diff --git a/js/src/jsapi.h b/js/src/jsapi.h
--- a/js/src/jsapi.h
+++ b/js/src/jsapi.h
@@ -1148,6 +1148,7 @@ class JS_PUBLIC_API(ContextOptions) {
         wasm_(false),
         wasmBaseline_(false),
         wasmIon_(false),
+        wasmAlwaysCretonne_(false),
         throwOnAsmJSValidationFailure_(false),
         nativeRegExp_(true),
         unboxedArrays_(false),
@@ -1231,6 +1232,16 @@ class JS_PUBLIC_API(ContextOptions) {
         return *this;
     }
 
+    bool wasmAlwaysCretonne() const { return wasmAlwaysCretonne_; }
+    ContextOptions& setWasmAlwaysCretonne(bool flag) {
+        wasmAlwaysCretonne_ = flag;
+        return *this;
+    }
+    ContextOptions& toggleWasmAlwaysCretonne() {
+        wasmAlwaysCretonne_ = !wasmAlwaysCretonne_;
+        return *this;
+    }
+
     bool throwOnAsmJSValidationFailure() const { return throwOnAsmJSValidationFailure_; }
     ContextOptions& setThrowOnAsmJSValidationFailure(bool flag) {
         throwOnAsmJSValidationFailure_ = flag;
@@ -1322,6 +1333,7 @@ class JS_PUBLIC_API(ContextOptions) {
     bool wasm_ : 1;
     bool wasmBaseline_ : 1;
     bool wasmIon_ : 1;
+    bool wasmAlwaysCretonne_ : 1;
     bool throwOnAsmJSValidationFailure_ : 1;
     bool nativeRegExp_ : 1;
     bool unboxedArrays_ : 1;
diff --git a/js/src/moz.build b/js/src/moz.build
--- a/js/src/moz.build
+++ b/js/src/moz.build
@@ -42,6 +42,8 @@ with Files('builtin/make_intl_data.py'):
     BUG_COMPONENT = component_intl
 
 
+DIRS += ['baldrdash']
+
 if CONFIG['JS_BUNDLED_EDITLINE']:
     DIRS += ['editline']
 
@@ -372,6 +374,7 @@ UNIFIED_SOURCES += [
     'wasm/WasmCode.cpp',
     'wasm/WasmCompartment.cpp',
     'wasm/WasmCompile.cpp',
+    'wasm/WasmCretonneCompile.cpp',
     'wasm/WasmDebug.cpp',
     'wasm/WasmFrameIter.cpp',
     'wasm/WasmGenerator.cpp',
diff --git a/js/src/shell/js.cpp b/js/src/shell/js.cpp
--- a/js/src/shell/js.cpp
+++ b/js/src/shell/js.cpp
@@ -265,6 +265,7 @@ static bool enableUnboxedArrays = false;
 static bool enableSharedMemory = SHARED_MEMORY_DEFAULT;
 static bool enableWasmBaseline = false;
 static bool enableWasmIon = false;
+static bool enableWasmAlwaysCretonne = false;
 static bool enableAsyncStacks = false;
 static bool enableStreams = false;
 #ifdef JS_GC_ZEAL
@@ -7842,6 +7843,7 @@ SetContextOptions(JSContext* cx, const O
     enableUnboxedArrays = op.getBoolOption("unboxed-arrays");
     enableWasmBaseline = !op.getBoolOption("no-wasm-baseline");
     enableWasmIon = !op.getBoolOption("no-wasm-ion");
+    enableWasmAlwaysCretonne = op.getBoolOption("wasm-always-cretonne");
     enableAsyncStacks = !op.getBoolOption("no-async-stacks");
     enableStreams = op.getBoolOption("enable-streams");
 
@@ -7851,6 +7853,7 @@ SetContextOptions(JSContext* cx, const O
                              .setWasm(enableWasm)
                              .setWasmBaseline(enableWasmBaseline)
                              .setWasmIon(enableWasmIon)
+                             .setWasmAlwaysCretonne(enableWasmAlwaysCretonne)
                              .setNativeRegExp(enableNativeRegExp)
                              .setUnboxedArrays(enableUnboxedArrays)
                              .setAsyncStack(enableAsyncStacks)
@@ -8138,6 +8141,7 @@ SetWorkerContextOptions(JSContext* cx)
                              .setWasm(enableWasm)
                              .setWasmBaseline(enableWasmBaseline)
                              .setWasmIon(enableWasmIon)
+                             .setWasmAlwaysCretonne(enableWasmAlwaysCretonne)
                              .setNativeRegExp(enableNativeRegExp)
                              .setUnboxedArrays(enableUnboxedArrays)
                              .setStreams(enableStreams);
@@ -8338,6 +8342,7 @@ main(int argc, char** argv, char** envp)
         || !op.addBoolOption('\0', "no-native-regexp", "Disable native regexp compilation")
         || !op.addBoolOption('\0', "no-unboxed-objects", "Disable creating unboxed plain objects")
         || !op.addBoolOption('\0', "unboxed-arrays", "Allow creating unboxed arrays")
+        || !op.addBoolOption('\0', "wasm-always-cretonne", "Enable wasm Cretonne compiler, crash when not possible")
         || !op.addBoolOption('\0', "wasm-check-bce", "Always generate wasm bounds check, even redundant ones.")
         || !op.addBoolOption('\0', "wasm-test-mode", "Enable wasm testing mode, creating synthetic "
                                    "objects for non-canonical NaNs and i64 returned from wasm.")
diff --git a/js/src/shell/moz.build b/js/src/shell/moz.build
--- a/js/src/shell/moz.build
+++ b/js/src/shell/moz.build
@@ -9,6 +9,7 @@ if CONFIG['JS_SHELL_NAME']:
     if CONFIG['JS_BUNDLED_EDITLINE']:
         USE_LIBS += ['editline']
     USE_LIBS += ['static:js']
+    USE_LIBS += ['baldrdash']
 
 UNIFIED_SOURCES += [
     'js.cpp',
diff --git a/js/src/wasm/WasmCompile.cpp b/js/src/wasm/WasmCompile.cpp
--- a/js/src/wasm/WasmCompile.cpp
+++ b/js/src/wasm/WasmCompile.cpp
@@ -101,6 +101,7 @@ CompileArgs::initFromContext(JSContext* 
 
     // For sanity's sake, just use Ion if both compilers are disabled.
     ionEnabled = cx->options().wasmIon() || !cx->options().wasmBaseline();
+    alwaysCretonne = cx->options().wasmAlwaysCretonne();
 
     // Debug information such as source view or debug traps will require
     // additional memory and permanently stay in baseline code, so we try to
@@ -209,6 +210,12 @@ Compile(ModuleGenerator& mg, const Share
 SharedModule
 wasm::CompileInitialTier(const ShareableBytes& bytecode, const CompileArgs& args, UniqueChars* error)
 {
+    // At the moment, Cretonne performs no validation, so validate explicitly.
+    if (args.alwaysCretonne) {
+        if (!Validate(bytecode, error))
+            return nullptr;
+    }
+
     ModuleGenerator mg(error, nullptr);
 
     CompileMode mode = GetInitialCompileMode(args);
diff --git a/js/src/wasm/WasmCompile.h b/js/src/wasm/WasmCompile.h
--- a/js/src/wasm/WasmCompile.h
+++ b/js/src/wasm/WasmCompile.h
@@ -40,6 +40,7 @@ struct CompileArgs : ShareableBase<Compi
     Assumptions assumptions;
     ScriptedCaller scriptedCaller;
     bool baselineEnabled;
+    bool alwaysCretonne;
     bool debugEnabled;
     bool ionEnabled;
 
@@ -47,6 +48,7 @@ struct CompileArgs : ShareableBase<Compi
       : assumptions(Move(assumptions)),
         scriptedCaller(Move(scriptedCaller)),
         baselineEnabled(false),
+        alwaysCretonne(false),
         debugEnabled(false),
         ionEnabled(false)
     {}
diff --git a/js/src/wasm/WasmCretonneCompile.cpp b/js/src/wasm/WasmCretonneCompile.cpp
new file mode 100644
--- /dev/null
+++ b/js/src/wasm/WasmCretonneCompile.cpp
@@ -0,0 +1,405 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ * vim: set ts=8 sts=4 et sw=4 tw=99:
+ *
+ * Copyright 2017 Mozilla Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "wasm/WasmCretonneCompile.h"
+
+extern "C" {
+// The API exported from this module to Rust.
+#include "baldrdash/baldrapi.h"
+}
+
+extern "C" {
+// The entry point exported from Rust.
+bool wasm_compile_function(const BD_WasmContext*);
+}
+
+struct Emitter
+{
+    MacroAssembler* masm;
+    FuncOffsets offsets;
+    // More here, likely.
+};
+
+struct WasmContext
+{
+    CompileTask* task;
+    const FuncBytes* func;
+    Emitter* emitter;
+};
+
+bool
+wasm::CretonneCompileFunction(CompileTask* task, FuncCompileUnit* unit, UniqueChars* error)
+{
+    MOZ_ASSERT(task->tier() == Tier::Ion);
+
+    Emitter em;
+    em.masm = &task->masm();
+
+    WasmContext cx;
+    cx.emitter = &em;
+    cx.task = task;
+    cx.func = &unit->func();
+
+    if (!wasm_compile_function(reinterpret_cast<const BD_WasmContext*>(&cx)))
+        return false;
+
+    unit->finish(em.offsets);
+
+    return true;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+//
+// Callbacks from Rust to C++.  These don't actually have to be named functions;
+// they could be members (function pointers) on the WasmContext structure.  But
+// there doesn't seem to be any harm in naming them.
+
+// Assert that we got the values right when we defined the API for Rust
+
+static_assert(BD_ExprType::ExprType_I32 == static_cast<int>(wasm::ExprType::I32), "Failed constraint");
+static_assert(BD_ExprType::ExprType_I64 == static_cast<int>(wasm::ExprType::I64), "Failed constraint");
+static_assert(BD_ExprType::ExprType_F32 == static_cast<int>(wasm::ExprType::F32), "Failed constraint");
+static_assert(BD_ExprType::ExprType_F64 == static_cast<int>(wasm::ExprType::F64), "Failed constraint");
+static_assert(BD_ExprType::ExprType_Void == static_cast<int>(wasm::ExprType::Void), "Failed constraint");
+
+static_assert(BD_MemoryUsage::MemoryUsage_None == static_cast<int>(wasm::MemoryUsage::None), "Failed constraint");
+static_assert(BD_MemoryUsage::MemoryUsage_Unshared == static_cast<int>(wasm::MemoryUsage::Unshared), "Failed constraint");
+static_assert(BD_MemoryUsage::MemoryUsage_Shared == static_cast<int>(wasm::MemoryUsage::Shared), "Failed constraint");
+
+static_assert(BD_ModuleKind::ModuleKind_Wasm == wasm::ModuleKind::Wasm, "Failed constraint");
+static_assert(BD_ModuleKind::ModuleKind_AsmJS == wasm::ModuleKind::AsmJS, "Failed constraint");
+
+static_assert(BD_SigIdDescKind::SigIdDescKind_None == static_cast<int>(wasm::SigIdDesc::Kind::None), "Failed constraint");
+static_assert(BD_SigIdDescKind::SigIdDescKind_Immediate == static_cast<int>(wasm::SigIdDesc::Kind::Immediate), "Failed constraint");
+static_assert(BD_SigIdDescKind::SigIdDescKind_Global == static_cast<int>(wasm::SigIdDesc::Kind::Global), "Failed constraint");
+
+static_assert(BD_ValType::ValType_I32 == static_cast<int>(wasm::ValType::I32), "Failed constraint");
+static_assert(BD_ValType::ValType_I64 == static_cast<int>(wasm::ValType::I64), "Failed constraint");
+static_assert(BD_ValType::ValType_F32 == static_cast<int>(wasm::ValType::F32), "Failed constraint");
+static_assert(BD_ValType::ValType_F64 == static_cast<int>(wasm::ValType::F64), "Failed constraint");
+
+// WasmContext
+
+const BD_ModuleEnvironment*
+cx_environment(const BD_WasmContext* cx_)
+{
+    const WasmContext* cx = reinterpret_cast<const WasmContext*>(cx_);
+    const ModuleEnvironment* env = &cx->task->env();
+    return reinterpret_cast<const BD_ModuleEnvironment*>(env);
+}
+
+const BD_FuncBytes*
+cx_funcBytes(const BD_WasmContext* cx_)
+{
+    const WasmContext* cx = reinterpret_cast<const WasmContext*>(cx_);
+    const FuncBytes* func = cx->func;
+    return reinterpret_cast<const BD_FuncBytes*>(func);
+}
+
+bool
+cx_debugEnabled(const BD_WasmContext* cx_)
+{
+    const WasmContext* cx = reinterpret_cast<const WasmContext*>(cx_);
+    return cx->task->debugEnabled();
+}
+
+const BD_Emitter*
+cx_emitter(const BD_WasmContext* cx_)
+{
+    const WasmContext* cx = reinterpret_cast<const WasmContext*>(cx_);
+    return reinterpret_cast<const BD_Emitter*>(cx->emitter);
+}
+
+// Emitter
+
+bool
+emitter_appendBytes(const BD_Emitter* em_, const uint8_t* begin, uint32_t count)
+{
+#ifdef DEBUG
+    // FIXME
+    fprintf(stderr, "  |");
+    for (uint32_t i=0; i < count; i++)
+        fprintf(stderr, " %02x", begin[i]);
+    fprintf(stderr, "\n");
+#endif
+
+    const Emitter* em = reinterpret_cast<const Emitter*>(em_);
+    return em->masm->appendBytes(begin, count);
+}
+
+void
+emitter_setBeginOffset(const BD_Emitter* em_, uint32_t offset)
+{
+    Emitter* em = const_cast<Emitter*>(reinterpret_cast<const Emitter*>(em_));
+    em->offsets.begin = offset;
+}
+
+void
+emitter_setEndOffset(const BD_Emitter* em_, uint32_t offset)
+{
+    Emitter* em = const_cast<Emitter*>(reinterpret_cast<const Emitter*>(em_));
+    em->offsets.end = offset;
+}
+
+void
+emitter_setRetOffset(const BD_Emitter* em_, uint32_t offset)
+{
+    Emitter* em = const_cast<Emitter*>(reinterpret_cast<const Emitter*>(em_));
+    em->offsets.ret = offset;
+}
+
+void
+emitter_setNormalEntryOffset(const BD_Emitter* em_, uint32_t offset)
+{
+    Emitter* em = const_cast<Emitter*>(reinterpret_cast<const Emitter*>(em_));
+    em->offsets.normalEntry = offset;
+}
+
+// ModuleEnvironment
+
+BD_ModuleKind
+env_kind(const BD_ModuleEnvironment* env_)
+{
+    const wasm::ModuleEnvironment* env = reinterpret_cast<const wasm::ModuleEnvironment*>(env_);
+    return BD_ModuleKind(int(env->kind));
+}
+
+const BD_Sig*
+env_functionSignature(const BD_ModuleEnvironment* env_, uint32_t funcIndex)
+{
+    const wasm::ModuleEnvironment* env = reinterpret_cast<const wasm::ModuleEnvironment*>(env_);
+    const Sig* sig = env->funcSigs[funcIndex];
+    return reinterpret_cast<const BD_Sig*>(sig);
+}
+
+uint32_t
+env_funcImportGlobalDataOffset(const BD_ModuleEnvironment* env_, uint32_t funcIndex)
+{
+    const wasm::ModuleEnvironment* env = reinterpret_cast<const wasm::ModuleEnvironment*>(env_);
+    return env->funcImportGlobalDataOffsets[funcIndex];
+}
+
+bool
+env_funcIsImport(const BD_ModuleEnvironment* env_, uint32_t funcIndex)
+{
+    const wasm::ModuleEnvironment* env = reinterpret_cast<const wasm::ModuleEnvironment*>(env_);
+    return env->funcIsImport(funcIndex);
+}
+
+const BD_SigWithId*
+env_signature(const BD_ModuleEnvironment* env_, uint32_t sigIndex)
+{
+    const wasm::ModuleEnvironment* env = reinterpret_cast<const wasm::ModuleEnvironment*>(env_);
+    const SigWithId* sig = &env->sigs[sigIndex];
+    return reinterpret_cast<const BD_SigWithId*>(sig);
+}
+
+uint32_t
+env_numTables(const BD_ModuleEnvironment* env_)
+{
+    const wasm::ModuleEnvironment* env = reinterpret_cast<const wasm::ModuleEnvironment*>(env_);
+    return env->tables.length();
+}
+
+const BD_TableDesc*
+env_table(const BD_ModuleEnvironment* env_, uint32_t tableIndex)
+{
+    const wasm::ModuleEnvironment* env = reinterpret_cast<const wasm::ModuleEnvironment*>(env_);
+    const TableDesc* table = &env->tables[0];
+    return reinterpret_cast<const BD_TableDesc*>(table);
+}
+
+const BD_GlobalDesc*
+env_global(const BD_ModuleEnvironment* env_, uint32_t globalIndex)
+{
+    const wasm::ModuleEnvironment* env = reinterpret_cast<const wasm::ModuleEnvironment*>(env_);
+    const GlobalDesc* global = &env->globals[globalIndex];
+    return reinterpret_cast<const BD_GlobalDesc*>(global);
+}
+
+uint32_t
+env_minMemoryLength(const BD_ModuleEnvironment* env_)
+{
+    const wasm::ModuleEnvironment* env = reinterpret_cast<const wasm::ModuleEnvironment*>(env_);
+    return env->minMemoryLength;
+}
+
+bool
+env_hasMaxMemoryLength(const BD_ModuleEnvironment* env_)
+{
+    const wasm::ModuleEnvironment* env = reinterpret_cast<const wasm::ModuleEnvironment*>(env_);
+    return env->maxMemoryLength.isSome();
+}
+
+uint32_t
+env_maxMemoryLength(const BD_ModuleEnvironment* env_)
+{
+    const wasm::ModuleEnvironment* env = reinterpret_cast<const wasm::ModuleEnvironment*>(env_);
+    if (env->maxMemoryLength.isSome())
+        return env->maxMemoryLength.value();
+    return 0;
+}
+
+BD_MemoryUsage
+env_memoryUsage(const BD_ModuleEnvironment* env_)
+{
+    const wasm::ModuleEnvironment* env = reinterpret_cast<const wasm::ModuleEnvironment*>(env_);
+    MemoryUsage mu = env->memoryUsage;
+    return BD_MemoryUsage(static_cast<int>(mu));
+}
+
+// FuncBytes
+
+const uint8_t* funcBytes_bytes(const BD_FuncBytes* fb_)
+{
+    const FuncBytes* fb = reinterpret_cast<const FuncBytes*>(fb_);
+    return fb->bytes().begin();
+}
+
+uint32_t funcBytes_numBytes(const BD_FuncBytes* fb_)
+{
+    const FuncBytes* fb = reinterpret_cast<const FuncBytes*>(fb_);
+    return fb->bytes().end() - fb->bytes().begin();
+}
+
+uint32_t funcBytes_lineOrBytecode(const BD_FuncBytes* fb_)
+{
+    const FuncBytes* fb = reinterpret_cast<const FuncBytes*>(fb_);
+    return fb->lineOrBytecode();
+}
+
+const BD_SigWithId* funcBytes_sig(const BD_FuncBytes* fb_)
+{
+    const FuncBytes* fb = reinterpret_cast<const FuncBytes*>(fb_);
+    const SigWithId* sig = &fb->sig();
+    return reinterpret_cast<const BD_SigWithId*>(sig);
+}
+
+uint32_t funcBytes_index(const BD_FuncBytes* fb_)
+{
+    const FuncBytes* fb = reinterpret_cast<const FuncBytes*>(fb_);
+    return fb->index();
+}
+
+const uint32_t* funcBytes_callSiteLineNums(const BD_FuncBytes* fb_)
+{
+    const FuncBytes* fb = reinterpret_cast<const FuncBytes*>(fb_);
+    return &fb->callSiteLineNums()[0];
+}
+
+uint32_t funcBytes_numCallSiteLineNums(const BD_FuncBytes* fb_)
+{
+    const FuncBytes* fb = reinterpret_cast<const FuncBytes*>(fb_);
+    return fb->callSiteLineNums().length();
+}
+
+// Global
+
+bool
+global_isConstant(const BD_GlobalDesc* global_)
+{
+    const GlobalDesc* global = reinterpret_cast<const GlobalDesc*>(global_);
+    return global->isConstant();
+}
+
+BD_ConstantValue
+global_constantValue(const BD_GlobalDesc* global_)
+{
+    const GlobalDesc* global = reinterpret_cast<const GlobalDesc*>(global_);
+    Val value = global->constantValue();
+    BD_ConstantValue v;
+    v.t = BD_ValType(int(value.type()));
+    switch (value.type()) {
+      case ValType::I32:
+        v.u.i32 = value.i32();
+        break;
+      case ValType::I64:
+        v.u.i64 = value.i64();
+        break;
+      case ValType::F32:
+        v.u.f32 = value.f32();
+        break;
+      case ValType::F64:
+        v.u.i64 = value.i64();
+        break;
+      default:
+        MOZ_CRASH("Bad type");
+    }
+    return v;
+}
+
+BD_ValType
+global_type(const BD_GlobalDesc* global_)
+{
+    const GlobalDesc* global = reinterpret_cast<const GlobalDesc*>(global_);
+    ValType type = global->type();
+    return BD_ValType(int(type));
+}
+
+// Sig
+
+uint32_t
+sig_numArgs(const BD_Sig* sig_)
+{
+    const Sig* sig = reinterpret_cast<const Sig*>(sig_);
+    return sig->args().length();
+}
+
+const BD_ValType*
+sig_args(const BD_Sig* sig_)
+{
+    const Sig* sig = reinterpret_cast<const Sig*>(sig_);
+    const ValType* args = &sig->args()[0];
+    return reinterpret_cast<const BD_ValType*>(args);
+}
+
+BD_ValType
+sig_argType(const BD_Sig* sig_, uint32_t argIndex)
+{
+    const Sig* sig = reinterpret_cast<const Sig*>(sig_);
+    ValType type = sig->args()[argIndex];
+    return BD_ValType(int(type));
+}
+
+BD_ExprType
+sig_retType(const BD_Sig* sig_)
+{
+    const Sig* sig = reinterpret_cast<const Sig*>(sig_);
+    ExprType ret = sig->ret();
+    return BD_ExprType(int(ret));
+}
+
+// SigWithId
+
+const BD_SigIdDesc*
+sigWithId_idDesc(const BD_SigWithId* sig_)
+{
+    const SigWithId* sig = reinterpret_cast<const SigWithId*>(sig_);
+    const SigIdDesc* sigId = &sig->id;
+    return reinterpret_cast<const BD_SigIdDesc*>(sigId);
+}
+
+// SigIdDesc
+
+BD_SigIdDescKind
+sigIdDesc_kind(const BD_SigIdDesc* desc_)
+{
+    const SigIdDesc* desc = reinterpret_cast<const SigIdDesc*>(desc_);
+    SigIdDesc::Kind kind = desc->kind();
+    return BD_SigIdDescKind(int(kind));
+}
diff --git a/js/src/wasm/WasmCretonneCompile.h b/js/src/wasm/WasmCretonneCompile.h
new file mode 100644
--- /dev/null
+++ b/js/src/wasm/WasmCretonneCompile.h
@@ -0,0 +1,39 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ * vim: set ts=8 sts=4 et sw=4 tw=99:
+ *
+ * Copyright 2017 Mozilla Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef wasm_cretonne_compile_h
+#define wasm_cretonne_compile_h
+
+#include "mozilla/Attributes.h"
+
+#include "wasm/WasmTypes.h"
+
+namespace js {
+namespace wasm {
+
+class CompileTask;
+class FuncCompileUnit;
+
+// Generates very fast code at the expense of compilation time.
+MOZ_MUST_USE bool
+CretonneCompileFunction(CompileTask* task, FuncCompileUnit* unit, UniqueChars* error);
+
+} // namespace wasm
+} // namespace js
+
+#endif // wasm_cretonne_compile_h
diff --git a/js/src/wasm/WasmGenerator.cpp b/js/src/wasm/WasmGenerator.cpp
--- a/js/src/wasm/WasmGenerator.cpp
+++ b/js/src/wasm/WasmGenerator.cpp
@@ -26,6 +26,7 @@
 
 #include "wasm/WasmBaselineCompile.h"
 #include "wasm/WasmCompile.h"
+#include "wasm/WasmCretonneCompile.h"
 #include "wasm/WasmIonCompile.h"
 #include "wasm/WasmStubs.h"
 
@@ -50,6 +51,7 @@ ModuleGenerator::ModuleGenerator(UniqueC
     tier_(Tier(-1)),
     error_(error),
     cancelled_(cancelled),
+    cretonneEnabled_(false),
     linkDataTier_(nullptr),
     metadataTier_(nullptr),
     numSigs_(0),
@@ -144,6 +146,7 @@ ModuleGenerator::initWasm(const CompileA
     MOZ_ASSERT(!env_->isAsmJS());
 
     tier_ = GetTier(args, compileMode_);
+    cretonneEnabled_ = args.alwaysCretonne;
 
     auto metadataTier = js::MakeUnique<MetadataTier>(tier_);
     if (!metadataTier)
@@ -960,6 +963,7 @@ ModuleGenerator::launchBatchCompile()
         return false;
 
     currentTask_->setDebugEnabled(metadata_->debugEnabled);
+    currentTask_->setCretonneEnabled(cretonneEnabled_);
 
     size_t numBatchedFuncs = currentTask_->units().length();
     MOZ_ASSERT(numBatchedFuncs);
@@ -1321,8 +1325,13 @@ wasm::CompileFunction(CompileTask* task,
     switch (task->tier()) {
       case Tier::Ion:
         for (FuncCompileUnit& unit : task->units()) {
-            if (!IonCompileFunction(task, &unit, error))
-                return false;
+            if (task->cretonneEnabled()) {
+                if (!CretonneCompileFunction(task, &unit, error))
+                    return false;
+            } else {
+                if (!IonCompileFunction(task, &unit, error))
+                    return false;
+            }
         }
         break;
       case Tier::Baseline:
diff --git a/js/src/wasm/WasmGenerator.h b/js/src/wasm/WasmGenerator.h
--- a/js/src/wasm/WasmGenerator.h
+++ b/js/src/wasm/WasmGenerator.h
@@ -139,6 +139,7 @@ class CompileTask
     Maybe<jit::MacroAssembler> masm_;
     FuncCompileUnitVector      units_;
     bool                       debugEnabled_;
+    bool                       cretonneEnabled_;
 
     CompileTask(const CompileTask&) = delete;
     CompileTask& operator=(const CompileTask&) = delete;
@@ -147,6 +148,7 @@ class CompileTask
         alloc_.emplace(&lifo_);
         masm_.emplace(jit::MacroAssembler::WasmToken(), *alloc_);
         debugEnabled_ = false;
+        cretonneEnabled_ = false;
     }
 
   public:
@@ -185,6 +187,12 @@ class CompileTask
     void setDebugEnabled(bool enabled) {
         debugEnabled_ = enabled;
     }
+    bool cretonneEnabled() const {
+        return cretonneEnabled_;
+    }
+    void setCretonneEnabled(bool enabled) {
+        cretonneEnabled_ = enabled;
+    }
     bool reset(UniqueFuncBytesVector* freeFuncBytes) {
         for (FuncCompileUnit& unit : units_) {
             if (!freeFuncBytes->emplaceBack(Move(unit.recycle())))
@@ -222,6 +230,7 @@ class MOZ_STACK_CLASS ModuleGenerator
     Tier                            tier_;
     UniqueChars*                    error_;
     Atomic<bool>*                   cancelled_;
+    bool                            cretonneEnabled_;
 
     // Data that is moved into the result of finish()
     Assumptions                     assumptions_;
