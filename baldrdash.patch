# HG changeset patch
# User Lars T Hansen <lhansen@mozilla.com>
# Date 1499384022 25200
#      Thu Jul 06 16:33:42 2017 -0700
# Node ID 786fd91b5296d92f194ba8db64e44d39ec857525
# Parent  5f7d4b62f6e497b3aa10f8c1171e86be52e54cf9
Baldrdash compilation framework

diff --git a/.hgignore b/.hgignore
--- a/.hgignore
+++ b/.hgignore
@@ -34,16 +34,17 @@
 
 # gecko.log is generated by various test harnesses
 ^gecko\.log
 
 # Build directories for js shell
 _DBG\.OBJ/
 _OPT\.OBJ/
 ^js/src/.*-obj/
+^js/src/baldrdash/target
 
 # SpiderMonkey configury
 ^js/src/configure$
 ^js/src/old-configure$
 ^js/src/autom4te.cache$
 # SpiderMonkey test result logs
 ^js/src/tests/results-.*\.(html|txt)$
 ^js/src/devtools/rootAnalysis/t/out
diff --git a/js/moz.configure b/js/moz.configure
--- a/js/moz.configure
+++ b/js/moz.configure
@@ -250,8 +250,14 @@ with only_when('--enable-compile-environ
         if fuzzing and not afl:
             return True
 
     set_config('FUZZING', enable_fuzzing)
     set_define('FUZZING', enable_fuzzing)
 
     set_config('LIBFUZZER', enable_libfuzzer)
     set_define('LIBFUZZER', enable_libfuzzer)
+
+# Rust
+# ==============================================================
+include('../build/moz.configure/rust.configure',
+        when='--enable-compile-environment')
+
diff --git a/js/src/baldrdash/Cargo.toml b/js/src/baldrdash/Cargo.toml
new file mode 100644
--- /dev/null
+++ b/js/src/baldrdash/Cargo.toml
@@ -0,0 +1,29 @@
+[package]
+name = "baldrdash"
+version = "0.1.0"
+authors = ["Lars T Hansen <lth@acm.org>"]
+
+[lib]
+name = "baldrdash"
+crate-type = ["staticlib"]
+
+[profile.release]
+opt-level = 3
+debug = false
+rpath = false
+lto = false
+debug-assertions = false
+# codegen-units ignored with lto=true
+codegen-units = 4
+panic = "abort"
+
+[profile.dev]
+opt-level = 0
+debug = true
+rpath = false
+lto = false
+debug-assertions = true
+codegen-units = 4
+panic = "abort"
+
+[dependencies]
diff --git a/js/src/baldrdash/Makefile b/js/src/baldrdash/Makefile
new file mode 100644
--- /dev/null
+++ b/js/src/baldrdash/Makefile
@@ -0,0 +1,27 @@
+src/baldrapi.rs: baldrapi.h Makefile
+	bindgen \
+	--whitelist-type ConstantValue \
+	--whitelist-type ExprType \
+	--whitelist-type GlobalDesc \
+	--whitelist-type MemoryUsage \
+	--whitelist-type ModuleEnvironment \
+	--whitelist-type Sig \
+	--whitelist-type SigWithId \
+	--whitelist-type SigIdDesc \
+	--whitelist-type SigIdDesc_Kind \
+	--whitelist-type TableDesc \
+	--whitelist-type ValType \
+	--whitelist-type WasmContext \
+	--whitelist-function 'global_.*' \
+	--whitelist-function 'sig_.*' \
+	--whitelist-function 'sigWithId_.*' \
+	--whitelist-function 'sigIdDesc_.*' \
+	--whitelist-function 'env_.*' \
+	--whitelist-function 'cx_.*' \
+	baldrapi.h | \
+	sed -e s/ValType_//g \
+	    -e s/ExprType_//g \
+	    -e s/MemoryUsage_//g \
+	    -e s/SigIdDesc_Kind_//g \
+	    -e s/BD_//g \
+	> src/baldrapi.rs
diff --git a/js/src/baldrdash/baldrapi.h b/js/src/baldrdash/baldrapi.h
new file mode 100644
--- /dev/null
+++ b/js/src/baldrdash/baldrapi.h
@@ -0,0 +1,137 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ * vim: set ts=8 sts=4 et sw=4 tw=99:
+ *
+ * Copyright 2017 Mozilla Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// This is a C API to the WebAssembly per-function compilation state, allowing
+// Rust to access constant metadata and produce output.
+//
+// The Rust code must export a single function as follows:
+//
+//    extern "C" bool wasm_compile_function(const WasmContext* context)
+//
+// and then call accessors on the context to obtain input and output data
+// structures.  The return value is true on success, false on OOM; there should
+// be no other errors, as the bytecode will already have been validated before
+// this call.
+
+// This file is input to Rust's bindgen, so as to create primitive APIs for the
+// Cretonne pipeline to access compilation metadata.  The output of bindgen is
+// postprocessed to remove all the BD_ prefixes and to remove the redundant type
+// name prefixes in the enums (eg, ValType::ValType_I32 becomes just
+// ValType::I32).  See Makefile in this directory for more.
+//
+// The actual Rust API then wraps these primitive APIs.  See src/baldrdash.rs.
+//
+// This file can be included in SpiderMonkey's C++ code, where all the prefixes
+// must be obeyed.  The purpose of the prefixes is to avoid type confusion.  See
+// js/src/wasm/WasmCretonneCompile.cpp.
+
+// DO NOT USE C++ IN THIS FILE.
+// DO NOT INCLUDE SPIDERMONKEY HEADER FILES INTO THIS FILE.
+
+#include <stdbool.h>
+#include <inttypes.h>
+
+// wasm/*.h, class and struct types that are opaque to us here
+
+typedef struct BD_WasmContext BD_WasmContext;
+typedef struct BD_ModuleEnvironment BD_ModuleEnvironment;
+typedef struct BD_Sig BD_Sig;
+typedef struct BD_SigWithId BD_SigWithId;
+typedef struct BD_SigIdDesc BD_SigIdDesc;
+typedef struct BD_TableDesc BD_TableDesc;
+typedef struct BD_GlobalDesc BD_GlobalDesc;
+
+// wasm/WasmBinaryConstants.h: enum class ValType
+
+typedef enum
+{
+    ValType_I32 = 0x7f,
+    ValType_I64 = 0x7e,
+    ValType_F32 = 0x7d,
+    ValType_F64 = 0x7c
+} BD_ValType;
+
+// wasm/WasmTypes.h: enum class ExprType
+
+typedef enum
+{
+    ExprType_Void = 0x40,
+
+    ExprType_I32 = 0x7f,
+    ExprType_I64 = 0x7e,
+    ExprType_F32 = 0x7d,
+    ExprType_F64 = 0x7c
+} BD_ExprType;
+
+// wasm/WasmCode.h: enum class MemoryUsage
+
+typedef enum
+{
+    MemoryUsage_None = 0,
+    MemoryUsage_Unshared = 1,
+    MemoryUsage_Shared = 2
+} BD_MemoryUsage;
+
+// Possible constant values for initializing globals
+
+typedef struct
+{
+    BD_ValType t;
+    union {
+	int32_t i32;
+	int64_t i64;
+	float f32;
+	double f64;
+    } u;
+} BD_ConstantValue;
+
+const BD_ModuleEnvironment* cx_environment(const BD_WasmContext*);
+
+uint32_t sig_length(const BD_Sig*);
+const BD_ValType* sig_args(const BD_Sig*);
+BD_ValType sig_argType(const BD_Sig*, uint32_t argIndex);
+BD_ExprType sig_retType(const BD_Sig*);
+
+const BD_SigIdDesc* sigWithId_idDesc(const BD_SigWithId*);
+
+// wasm/WasmTypes.h: enum class Kind within class SigIdDesc
+
+typedef enum
+{
+    SigIdDesc_Kind_None = 0,
+    SigIdDesc_Kind_Immediate = 1,
+    SigIdDesc_Kind_Global = 2
+} BD_SigIdDescKind;
+
+BD_SigIdDescKind sigIdDesc_kind(const BD_SigIdDesc*);
+
+const BD_Sig* env_functionSignature(const BD_ModuleEnvironment*, uint32_t funcIndex);
+uint32_t env_funcImportGlobalDataOffset(const BD_ModuleEnvironment*, uint32_t funcIndex);
+bool env_funcIsImport(const BD_ModuleEnvironment*, uint32_t funcIndex);
+const BD_SigWithId* env_signature(const BD_ModuleEnvironment*, uint32_t sigIndex);
+uint32_t env_numTables(const BD_ModuleEnvironment*);
+const BD_TableDesc* env_table(const BD_ModuleEnvironment*, uint32_t tableIndex);
+const BD_GlobalDesc* env_global(const BD_ModuleEnvironment*, uint32_t globalIndex);
+uint32_t env_minMemoryLength(const BD_ModuleEnvironment*);
+bool env_hasMaxMemoryLength(const BD_ModuleEnvironment*);
+uint32_t env_maxMemoryLength(const BD_ModuleEnvironment*);
+BD_MemoryUsage env_memoryUsage(const BD_ModuleEnvironment*);
+
+bool global_isConstant(const BD_GlobalDesc*);
+BD_ConstantValue global_constantValue(const BD_GlobalDesc*);
+BD_ValType global_type(const BD_GlobalDesc*);
diff --git a/js/src/baldrdash/moz.build b/js/src/baldrdash/moz.build
new file mode 100644
--- /dev/null
+++ b/js/src/baldrdash/moz.build
@@ -0,0 +1,7 @@
+# -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
+# vim: set filetype=python:
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+RustLibrary('baldrdash')
diff --git a/js/src/baldrdash/src/baldrapi.rs b/js/src/baldrdash/src/baldrapi.rs
new file mode 100644
--- /dev/null
+++ b/js/src/baldrdash/src/baldrapi.rs
@@ -0,0 +1,237 @@
+/* automatically generated by rust-bindgen */
+
+#[repr(C)]
+pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
+impl <T> __BindgenUnionField<T> {
+    #[inline]
+    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
+    #[inline]
+    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
+    #[inline]
+    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
+}
+impl <T> ::std::default::Default for __BindgenUnionField<T> {
+    #[inline]
+    fn default() -> Self { Self::new() }
+}
+impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
+    #[inline]
+    fn clone(&self) -> Self { Self::new() }
+}
+impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
+impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
+    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
+        fmt.write_str("__BindgenUnionField")
+    }
+}
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct WasmContext {
+    _unused: [u8; 0],
+}
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct ModuleEnvironment {
+    _unused: [u8; 0],
+}
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct Sig {
+    _unused: [u8; 0],
+}
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct SigWithId {
+    _unused: [u8; 0],
+}
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct SigIdDesc {
+    _unused: [u8; 0],
+}
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct TableDesc {
+    _unused: [u8; 0],
+}
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct GlobalDesc {
+    _unused: [u8; 0],
+}
+#[repr(u32)]
+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
+pub enum ValType {
+    I32 = 127,
+    I64 = 126,
+    F32 = 125,
+    F64 = 124,
+}
+#[repr(u32)]
+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
+pub enum ExprType {
+    Void = 64,
+    I32 = 127,
+    I64 = 126,
+    F32 = 125,
+    F64 = 124,
+}
+#[repr(u32)]
+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
+pub enum MemoryUsage {
+    None = 0,
+    Unshared = 1,
+    Shared = 2,
+}
+#[repr(C)]
+#[derive(Debug, Copy)]
+pub struct ConstantValue {
+    pub t: ValType,
+    pub u: ConstantValue__bindgen_ty_1,
+}
+#[repr(C)]
+#[derive(Debug, Copy)]
+pub struct ConstantValue__bindgen_ty_1 {
+    pub i32: __BindgenUnionField<i32>,
+    pub i64: __BindgenUnionField<i64>,
+    pub f32: __BindgenUnionField<f32>,
+    pub f64: __BindgenUnionField<f64>,
+    pub bindgen_union_field: u64,
+}
+#[test]
+fn bindgen_test_layout_ConstantValue__bindgen_ty_1() {
+    assert_eq!(::std::mem::size_of::<ConstantValue__bindgen_ty_1>() ,
+               8usize , concat ! (
+               "Size of: " , stringify ! ( ConstantValue__bindgen_ty_1 )
+               ));
+    assert_eq! (::std::mem::align_of::<ConstantValue__bindgen_ty_1>() ,
+                8usize , concat ! (
+                "Alignment of " , stringify ! ( ConstantValue__bindgen_ty_1
+                ) ));
+    assert_eq! (unsafe {
+                & ( * ( 0 as * const ConstantValue__bindgen_ty_1 ) ) . i32
+                as * const _ as usize } , 0usize , concat ! (
+                "Alignment of field: " , stringify ! (
+                ConstantValue__bindgen_ty_1 ) , "::" , stringify ! ( i32 )
+                ));
+    assert_eq! (unsafe {
+                & ( * ( 0 as * const ConstantValue__bindgen_ty_1 ) ) . i64
+                as * const _ as usize } , 0usize , concat ! (
+                "Alignment of field: " , stringify ! (
+                ConstantValue__bindgen_ty_1 ) , "::" , stringify ! ( i64 )
+                ));
+    assert_eq! (unsafe {
+                & ( * ( 0 as * const ConstantValue__bindgen_ty_1 ) ) . f32
+                as * const _ as usize } , 0usize , concat ! (
+                "Alignment of field: " , stringify ! (
+                ConstantValue__bindgen_ty_1 ) , "::" , stringify ! ( f32 )
+                ));
+    assert_eq! (unsafe {
+                & ( * ( 0 as * const ConstantValue__bindgen_ty_1 ) ) . f64
+                as * const _ as usize } , 0usize , concat ! (
+                "Alignment of field: " , stringify ! (
+                ConstantValue__bindgen_ty_1 ) , "::" , stringify ! ( f64 )
+                ));
+}
+impl Clone for ConstantValue__bindgen_ty_1 {
+    fn clone(&self) -> Self { *self }
+}
+#[test]
+fn bindgen_test_layout_ConstantValue() {
+    assert_eq!(::std::mem::size_of::<ConstantValue>() , 16usize , concat !
+               ( "Size of: " , stringify ! ( ConstantValue ) ));
+    assert_eq! (::std::mem::align_of::<ConstantValue>() , 8usize , concat !
+                ( "Alignment of " , stringify ! ( ConstantValue ) ));
+    assert_eq! (unsafe {
+                & ( * ( 0 as * const ConstantValue ) ) . t as * const _ as
+                usize } , 0usize , concat ! (
+                "Alignment of field: " , stringify ! ( ConstantValue ) ,
+                "::" , stringify ! ( t ) ));
+    assert_eq! (unsafe {
+                & ( * ( 0 as * const ConstantValue ) ) . u as * const _ as
+                usize } , 8usize , concat ! (
+                "Alignment of field: " , stringify ! ( ConstantValue ) ,
+                "::" , stringify ! ( u ) ));
+}
+impl Clone for ConstantValue {
+    fn clone(&self) -> Self { *self }
+}
+extern "C" {
+    pub fn cx_environment(arg1: *const WasmContext)
+     -> *const ModuleEnvironment;
+}
+extern "C" {
+    pub fn sig_length(arg1: *const Sig) -> u32;
+}
+extern "C" {
+    pub fn sig_args(arg1: *const Sig) -> *const ValType;
+}
+extern "C" {
+    pub fn sig_argType(arg1: *const Sig, argIndex: u32) -> ValType;
+}
+extern "C" {
+    pub fn sig_retType(arg1: *const Sig) -> ExprType;
+}
+extern "C" {
+    pub fn sigWithId_idDesc(arg1: *const SigWithId) -> *const SigIdDesc;
+}
+#[repr(u32)]
+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
+pub enum SigIdDescKind {
+    None = 0,
+    Immediate = 1,
+    Global = 2,
+}
+extern "C" {
+    pub fn sigIdDesc_kind(arg1: *const SigIdDesc) -> SigIdDescKind;
+}
+extern "C" {
+    pub fn env_functionSignature(arg1: *const ModuleEnvironment,
+                                 funcIndex: u32) -> *const Sig;
+}
+extern "C" {
+    pub fn env_funcImportGlobalDataOffset(arg1: *const ModuleEnvironment,
+                                          funcIndex: u32) -> u32;
+}
+extern "C" {
+    pub fn env_funcIsImport(arg1: *const ModuleEnvironment, funcIndex: u32)
+     -> bool;
+}
+extern "C" {
+    pub fn env_signature(arg1: *const ModuleEnvironment, sigIndex: u32)
+     -> *const SigWithId;
+}
+extern "C" {
+    pub fn env_numTables(arg1: *const ModuleEnvironment) -> u32;
+}
+extern "C" {
+    pub fn env_table(arg1: *const ModuleEnvironment, tableIndex: u32)
+     -> *const TableDesc;
+}
+extern "C" {
+    pub fn env_global(arg1: *const ModuleEnvironment, globalIndex: u32)
+     -> *const GlobalDesc;
+}
+extern "C" {
+    pub fn env_minMemoryLength(arg1: *const ModuleEnvironment) -> u32;
+}
+extern "C" {
+    pub fn env_hasMaxMemoryLength(arg1: *const ModuleEnvironment) -> bool;
+}
+extern "C" {
+    pub fn env_maxMemoryLength(arg1: *const ModuleEnvironment) -> u32;
+}
+extern "C" {
+    pub fn env_memoryUsage(arg1: *const ModuleEnvironment)
+     -> MemoryUsage;
+}
+extern "C" {
+    pub fn global_isConstant(arg1: *const GlobalDesc) -> bool;
+}
+extern "C" {
+    pub fn global_constantValue(arg1: *const GlobalDesc)
+     -> ConstantValue;
+}
+extern "C" {
+    pub fn global_type(arg1: *const GlobalDesc) -> ValType;
+}
diff --git a/js/src/baldrdash/src/baldrdash.rs b/js/src/baldrdash/src/baldrdash.rs
new file mode 100644
--- /dev/null
+++ b/js/src/baldrdash/src/baldrdash.rs
@@ -0,0 +1,141 @@
+// Safe wrappers to the low-level ABI.  This re-exports all types in
+// baldrapi but none of the functions.
+//
+// There are other options than an ADT interface here; the WasmContext
+// could be packaged up as a Rust object, with methods on it, and so
+// on.  There's more complexity in that, notably in storage
+// management.  Perhaps traits could be brought to bear.
+
+// TODO: should many u32 arguments and return values here really be
+// usize, to be more conventional?
+
+use std::slice;
+
+use baldrapi;
+
+pub use baldrapi::ExprType;
+pub use baldrapi::GlobalDesc;
+pub use baldrapi::MemoryUsage;
+pub use baldrapi::ModuleEnvironment;
+pub use baldrapi::Sig;
+pub use baldrapi::SigIdDesc;
+pub use baldrapi::SigIdDescKind;
+pub use baldrapi::SigWithId;
+pub use baldrapi::TableDesc;
+pub use baldrapi::ValType;
+pub use baldrapi::WasmContext;
+
+pub enum ConstantValue {
+    I32(i32),
+    I64(i64),
+    F32(f32),
+    F64(f64)
+}
+
+// WasmContext accessors
+
+pub fn cx_environment(cx:*const WasmContext) -> *const ModuleEnvironment {
+    unsafe { baldrapi::cx_environment(cx) }
+}
+
+// ModuleEnvironment accessors
+
+pub fn env_functionSignature(env:*const ModuleEnvironment, func_index:u32) -> *const Sig {
+    unsafe { baldrapi::env_functionSignature(env, func_index) }
+}
+
+pub fn env_func_is_import(env:*const ModuleEnvironment, func_index:u32) -> bool {
+    unsafe { baldrapi::env_funcIsImport(env, func_index) }
+}
+
+pub fn env_func_import_global_data_offset(env:*const ModuleEnvironment, func_index:u32) -> u32 {
+    unsafe { baldrapi::env_funcImportGlobalDataOffset(env, func_index) }
+}
+
+pub fn env_signature(env:*const ModuleEnvironment, sig_index:u32) -> *const SigWithId {
+    unsafe { baldrapi::env_signature(env, sig_index) }
+}
+
+pub fn env_num_tables(env:*const ModuleEnvironment) -> u32 {
+    unsafe { baldrapi::env_numTables(env) }
+}
+
+pub fn env_table(env:*const ModuleEnvironment, table_index:u32) -> *const TableDesc {
+    unsafe { baldrapi::env_table(env, table_index) }
+}
+
+pub fn env_global(env:*const ModuleEnvironment, global_index:u32) -> *const GlobalDesc {
+    unsafe { baldrapi::env_global(env, global_index) }
+}
+
+pub fn env_min_memory_length(env:*const ModuleEnvironment) -> u32 {
+    unsafe { baldrapi::env_minMemoryLength(env) }
+}
+
+pub fn env_max_memory_length(env:*const ModuleEnvironment) -> Option<u32> {
+    unsafe {
+        if baldrapi::env_hasMaxMemoryLength(env) {
+            Some(baldrapi::env_maxMemoryLength(env))
+        } else {
+            None
+        }
+    }
+}
+
+pub fn env_memory_usage(env:*const ModuleEnvironment) -> MemoryUsage {
+    unsafe { baldrapi::env_memoryUsage(env) }
+}
+
+// Sig accessors
+
+pub fn sig_length(sig:*const Sig) -> u32 {
+    unsafe { baldrapi::sig_length(sig) }
+}
+
+pub fn sig_args<'a>(sig:*const Sig) -> &'a [ValType] {
+    unsafe {
+        slice::from_raw_parts(baldrapi::sig_args(sig),
+                              baldrapi::sig_length(sig) as usize)
+    }
+}
+
+pub fn sig_arg_type(sig:*const Sig, arg_index: u32) -> ValType {
+    unsafe { baldrapi::sig_argType(sig, arg_index) }
+}
+
+pub fn sig_ret_type(sig:*const Sig) -> ExprType {
+    unsafe { baldrapi::sig_retType(sig) }
+}
+
+pub fn sig_with_id_id_desc(sig_with_id:*const SigWithId) -> *const SigIdDesc {
+    unsafe { baldrapi::sigWithId_idDesc(sig_with_id) }
+}
+
+// SigIdDesc accessors
+
+pub fn sig_id_desc_kind(desc:*const SigIdDesc) -> SigIdDescKind {
+    unsafe { baldrapi::sigIdDesc_kind(desc) }
+}
+
+// Global accessors
+
+pub fn global_type(global:*const GlobalDesc) -> ValType {
+    unsafe { baldrapi::global_type(global) }
+}
+
+pub fn global_constant_value(global:*const GlobalDesc) -> Option<ConstantValue> {
+    unsafe {
+        if !baldrapi::global_isConstant(global) {
+            return None
+        }
+        let v = baldrapi::global_constantValue(global);
+        match v.t {
+            ValType::I32 => Some(ConstantValue::I32(*v.u.i32.as_ref())),
+            ValType::I64 => Some(ConstantValue::I64(*v.u.i64.as_ref())),
+            ValType::F32 => Some(ConstantValue::F32(*v.u.f32.as_ref())),
+            ValType::F64 => Some(ConstantValue::F64(*v.u.f64.as_ref()))
+        }
+    }
+}
+
+
diff --git a/js/src/baldrdash/src/lib.rs b/js/src/baldrdash/src/lib.rs
new file mode 100644
--- /dev/null
+++ b/js/src/baldrdash/src/lib.rs
@@ -0,0 +1,22 @@
+#![allow(non_snake_case)]
+#![allow(non_camel_case_types)]
+#![allow(unused)]
+
+mod baldrapi;
+mod baldrdash;
+
+use baldrdash::*;
+
+#[no_mangle]
+pub extern fn wasm_compile_function(cx:*const WasmContext) -> bool {
+    let env = cx_environment(cx);
+    println!("{}", env_num_tables(env));
+    true
+}
+
+#[cfg(test)]
+mod tests {
+    #[test]
+    fn it_works() {
+    }
+}
diff --git a/js/src/build/moz.build b/js/src/build/moz.build
--- a/js/src/build/moz.build
+++ b/js/src/build/moz.build
@@ -38,16 +38,17 @@ if CONFIG['ENABLE_INTL_API']:
         # Linking 'icu' will pull in the stubdata library,
         # which the shell doesn't want, so link the other bits.
         USE_LIBS += [
             'icui18n',
             'icuuc',
         ]
 
 USE_LIBS += [
+    'baldrdash',
     'nspr',
     'zlib',
 ]
 
 if CONFIG['OS_ARCH'] not in ('WINNT', 'HP-UX'):
     OS_LIBS += [
         'm',
     ]
diff --git a/js/src/gdb/moz.build b/js/src/gdb/moz.build
--- a/js/src/gdb/moz.build
+++ b/js/src/gdb/moz.build
@@ -26,19 +26,21 @@ UNIFIED_SOURCES += [
 DEFINES['EXPORT_JS_API'] = True
 
 LOCAL_INCLUDES += [
     '!..',
     '..',
 ]
 
 USE_LIBS += [
-    'static:js',
+    'static:js'
 ]
 
+USE_LIBS += [ 'baldrdash' ]
+
 if CONFIG['ENABLE_INTL_API'] and CONFIG['MOZ_ICU_DATA_ARCHIVE']:
     # The ICU libraries linked into libmozjs will not include the ICU data,
     # so link it directly.
     USE_LIBS += ['icudata']
 
 OS_LIBS += CONFIG['MOZ_ZLIB_LIBS']
 
 if CONFIG['GNU_CXX']:
diff --git a/js/src/jsapi-tests/moz.build b/js/src/jsapi-tests/moz.build
--- a/js/src/jsapi-tests/moz.build
+++ b/js/src/jsapi-tests/moz.build
@@ -133,19 +133,21 @@ LOCAL_INCLUDES += [
 ]
 
 if CONFIG['ENABLE_INTL_API'] and CONFIG['MOZ_ICU_DATA_ARCHIVE']:
     # The ICU libraries linked into libmozjs will not include the ICU data,
     # so link it directly.
     USE_LIBS += ['icudata']
 
 USE_LIBS += [
-    'static:js',
+    'static:js'
 ]
 
+USE_LIBS += [ 'baldrdash' ]
+
 OS_LIBS += CONFIG['MOZ_ZLIB_LIBS']
 
 if CONFIG['GNU_CXX']:
     CXXFLAGS += ['-Wno-shadow', '-Werror=format', '-fno-strict-aliasing']
 
 # This is intended as a temporary workaround to enable VS2015.
 if CONFIG['_MSC_VER']:
     CXXFLAGS += ['-wd4312']
diff --git a/js/src/jsapi.h b/js/src/jsapi.h
--- a/js/src/jsapi.h
+++ b/js/src/jsapi.h
@@ -1139,16 +1139,17 @@ namespace JS {
 class JS_PUBLIC_API(ContextOptions) {
   public:
     ContextOptions()
       : baseline_(true),
         ion_(true),
         asmJS_(true),
         wasm_(false),
         wasmAlwaysBaseline_(false),
+        wasmAlwaysCretonne_(false),
         throwOnAsmJSValidationFailure_(false),
         nativeRegExp_(true),
         unboxedArrays_(false),
         asyncStack_(true),
         throwOnDebuggeeWouldRun_(true),
         dumpStackOnDebuggeeWouldRun_(false),
         werror_(false),
         strictMode_(false),
@@ -1206,16 +1207,26 @@ class JS_PUBLIC_API(ContextOptions) {
         wasmAlwaysBaseline_ = flag;
         return *this;
     }
     ContextOptions& toggleWasmAlwaysBaseline() {
         wasmAlwaysBaseline_ = !wasmAlwaysBaseline_;
         return *this;
     }
 
+    bool wasmAlwaysCretonne() const { return wasmAlwaysCretonne_; }
+    ContextOptions& setWasmAlwaysCretonne(bool flag) {
+        wasmAlwaysCretonne_ = flag;
+        return *this;
+    }
+    ContextOptions& toggleWasmAlwaysCretonne() {
+        wasmAlwaysCretonne_ = !wasmAlwaysCretonne_;
+        return *this;
+    }
+
     bool throwOnAsmJSValidationFailure() const { return throwOnAsmJSValidationFailure_; }
     ContextOptions& setThrowOnAsmJSValidationFailure(bool flag) {
         throwOnAsmJSValidationFailure_ = flag;
         return *this;
     }
     ContextOptions& toggleThrowOnAsmJSValidationFailure() {
         throwOnAsmJSValidationFailure_ = !throwOnAsmJSValidationFailure_;
         return *this;
@@ -1296,16 +1307,17 @@ class JS_PUBLIC_API(ContextOptions) {
 #endif
 
   private:
     bool baseline_ : 1;
     bool ion_ : 1;
     bool asmJS_ : 1;
     bool wasm_ : 1;
     bool wasmAlwaysBaseline_ : 1;
+    bool wasmAlwaysCretonne_ : 1;
     bool throwOnAsmJSValidationFailure_ : 1;
     bool nativeRegExp_ : 1;
     bool unboxedArrays_ : 1;
     bool asyncStack_ : 1;
     bool throwOnDebuggeeWouldRun_ : 1;
     bool dumpStackOnDebuggeeWouldRun_ : 1;
     bool werror_ : 1;
     bool strictMode_ : 1;
diff --git a/js/src/moz.build b/js/src/moz.build
--- a/js/src/moz.build
+++ b/js/src/moz.build
@@ -37,16 +37,18 @@ for stlfile in ['jsarray.*', 'jsbool*', 
         BUG_COMPONENT = component_stl
 
 with Files('builtin/Intl*'):
     BUG_COMPONENT = component_intl
 with Files('builtin/make_intl_data.py'):
     BUG_COMPONENT = component_intl
 
 
+DIRS += ['baldrdash']
+
 if CONFIG['JS_BUNDLED_EDITLINE']:
     DIRS += ['editline']
 
 if not CONFIG['JS_DISABLE_SHELL']:
     DIRS += ['shell']
 
 TEST_DIRS += ['jsapi-tests', 'tests', 'gdb']
 
@@ -366,16 +368,17 @@ UNIFIED_SOURCES += [
     'wasm/WasmBinaryIterator.cpp',
     'wasm/WasmBinaryToAST.cpp',
     'wasm/WasmBinaryToExperimentalText.cpp',
     'wasm/WasmBinaryToText.cpp',
     'wasm/WasmBuiltins.cpp',
     'wasm/WasmCode.cpp',
     'wasm/WasmCompartment.cpp',
     'wasm/WasmCompile.cpp',
+    'wasm/WasmCretonneCompile.cpp',
     'wasm/WasmDebug.cpp',
     'wasm/WasmFrameIterator.cpp',
     'wasm/WasmGenerator.cpp',
     'wasm/WasmInstance.cpp',
     'wasm/WasmIonCompile.cpp',
     'wasm/WasmJS.cpp',
     'wasm/WasmModule.cpp',
     'wasm/WasmSignalHandlers.cpp',
diff --git a/js/src/shell/js.cpp b/js/src/shell/js.cpp
--- a/js/src/shell/js.cpp
+++ b/js/src/shell/js.cpp
@@ -262,16 +262,17 @@ static bool offthreadCompilation = false
 static bool enableBaseline = false;
 static bool enableIon = false;
 static bool enableAsmJS = false;
 static bool enableWasm = false;
 static bool enableNativeRegExp = false;
 static bool enableUnboxedArrays = false;
 static bool enableSharedMemory = SHARED_MEMORY_DEFAULT;
 static bool enableWasmAlwaysBaseline = false;
+static bool enableWasmAlwaysCretonne = false;
 static bool enableAsyncStacks = false;
 #ifdef JS_GC_ZEAL
 static uint32_t gZealBits = 0;
 static uint32_t gZealFrequency = 0;
 #endif
 static bool printTiming = false;
 static const char* jsCacheDir = nullptr;
 static const char* jsCacheAsmJSPath = nullptr;
@@ -7767,23 +7768,25 @@ SetContextOptions(JSContext* cx, const O
 {
     enableBaseline = !op.getBoolOption("no-baseline");
     enableIon = !op.getBoolOption("no-ion");
     enableAsmJS = !op.getBoolOption("no-asmjs");
     enableWasm = !op.getBoolOption("no-wasm");
     enableNativeRegExp = !op.getBoolOption("no-native-regexp");
     enableUnboxedArrays = op.getBoolOption("unboxed-arrays");
     enableWasmAlwaysBaseline = op.getBoolOption("wasm-always-baseline");
+    enableWasmAlwaysCretonne = op.getBoolOption("wasm-always-cretonne");
     enableAsyncStacks = !op.getBoolOption("no-async-stacks");
 
     JS::ContextOptionsRef(cx).setBaseline(enableBaseline)
                              .setIon(enableIon)
                              .setAsmJS(enableAsmJS)
                              .setWasm(enableWasm)
                              .setWasmAlwaysBaseline(enableWasmAlwaysBaseline)
+                             .setWasmAlwaysCretonne(enableWasmAlwaysCretonne)
                              .setNativeRegExp(enableNativeRegExp)
                              .setUnboxedArrays(enableUnboxedArrays)
                              .setAsyncStack(enableAsyncStacks);
 
     if (op.getBoolOption("wasm-check-bce"))
         jit::JitOptions.wasmAlwaysCheckBounds = true;
 
     if (op.getBoolOption("wasm-test-mode"))
@@ -8059,16 +8062,17 @@ static void
 SetWorkerContextOptions(JSContext* cx)
 {
     // Copy option values from the main thread.
     JS::ContextOptionsRef(cx).setBaseline(enableBaseline)
                              .setIon(enableIon)
                              .setAsmJS(enableAsmJS)
                              .setWasm(enableWasm)
                              .setWasmAlwaysBaseline(enableWasmAlwaysBaseline)
+                             .setWasmAlwaysCretonne(enableWasmAlwaysCretonne)
                              .setNativeRegExp(enableNativeRegExp)
                              .setUnboxedArrays(enableUnboxedArrays);
     cx->runtime()->setOffthreadIonCompilationEnabled(offthreadCompilation);
     cx->runtime()->profilingScripts = enableCodeCoverage || enableDisassemblyDumps;
 
 #ifdef JS_GC_ZEAL
     if (gZealBits && gZealFrequency) {
 #define ZEAL_MODE(_, value)                        \
@@ -8257,16 +8261,17 @@ main(int argc, char** argv, char** envp)
         || !op.addBoolOption('\0', "ion", "Enable IonMonkey (default)")
         || !op.addBoolOption('\0', "no-ion", "Disable IonMonkey")
         || !op.addBoolOption('\0', "no-asmjs", "Disable asm.js compilation")
         || !op.addBoolOption('\0', "no-wasm", "Disable WebAssembly compilation")
         || !op.addBoolOption('\0', "no-native-regexp", "Disable native regexp compilation")
         || !op.addBoolOption('\0', "no-unboxed-objects", "Disable creating unboxed plain objects")
         || !op.addBoolOption('\0', "unboxed-arrays", "Allow creating unboxed arrays")
         || !op.addBoolOption('\0', "wasm-always-baseline", "Enable wasm baseline compiler when possible")
+        || !op.addBoolOption('\0', "wasm-always-cretonne", "Enable wasm Cretonne compiler, crash when not possible")
         || !op.addBoolOption('\0', "wasm-check-bce", "Always generate wasm bounds check, even redundant ones.")
         || !op.addBoolOption('\0', "wasm-test-mode", "Enable wasm testing mode, creating synthetic "
                                    "objects for non-canonical NaNs and i64 returned from wasm.")
 #ifdef ENABLE_SHARED_ARRAY_BUFFER
         || !op.addStringOption('\0', "shared-memory", "on/off",
                                "SharedArrayBuffer and Atomics "
 #  if SHARED_MEMORY_DEFAULT
                                "(default: on, off to disable)"
diff --git a/js/src/shell/moz.build b/js/src/shell/moz.build
--- a/js/src/shell/moz.build
+++ b/js/src/shell/moz.build
@@ -3,17 +3,18 @@
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 if CONFIG['JS_SHELL_NAME']:
     GeckoProgram(CONFIG['JS_SHELL_NAME'], linkage=None)
     if CONFIG['JS_BUNDLED_EDITLINE']:
         USE_LIBS += ['editline']
-    USE_LIBS += ['static:js']
+    USE_LIBS += [ 'static:js' ]
+    USE_LIBS += [ 'baldrdash' ]
 
 UNIFIED_SOURCES += [
     'js.cpp',
     'jsoptparse.cpp',
     'jsshell.cpp',
     'OSObject.cpp'
 ]
 
diff --git a/js/src/wasm/WasmCompile.cpp b/js/src/wasm/WasmCompile.cpp
--- a/js/src/wasm/WasmCompile.cpp
+++ b/js/src/wasm/WasmCompile.cpp
@@ -89,16 +89,17 @@ DecodeCodeSection(Decoder& d, ModuleGene
 
     return mg.finishFuncDefs();
 }
 
 bool
 CompileArgs::initFromContext(JSContext* cx, ScriptedCaller&& scriptedCaller)
 {
     alwaysBaseline = cx->options().wasmAlwaysBaseline();
+    alwaysCretonne = cx->options().wasmAlwaysCretonne();
 
     // Debug information such as source view or debug traps will require
     // additional memory and permanently stay in baseline code, so we try to
     // only enable it when a developer actually cares: when the debugger tab
     // is open.
     debugEnabled = cx->compartment()->debuggerObservesAsmJS();
 
     this->scriptedCaller = Move(scriptedCaller);
diff --git a/js/src/wasm/WasmCompile.h b/js/src/wasm/WasmCompile.h
--- a/js/src/wasm/WasmCompile.h
+++ b/js/src/wasm/WasmCompile.h
@@ -35,22 +35,24 @@ struct ScriptedCaller
 
 // Describes all the parameters that control wasm compilation.
 
 struct CompileArgs
 {
     Assumptions assumptions;
     ScriptedCaller scriptedCaller;
     bool alwaysBaseline;
+    bool alwaysCretonne;
     bool debugEnabled;
 
     CompileArgs(Assumptions&& assumptions, ScriptedCaller&& scriptedCaller)
       : assumptions(Move(assumptions)),
         scriptedCaller(Move(scriptedCaller)),
         alwaysBaseline(false),
+        alwaysCretonne(false),
         debugEnabled(false)
     {}
 
     // If CompileArgs is constructed without arguments, initFromContext() must
     // be called to complete initialization.
     CompileArgs() = default;
     bool initFromContext(JSContext* cx, ScriptedCaller&& scriptedCaller);
 };
diff --git a/js/src/wasm/WasmCretonneCompile.cpp b/js/src/wasm/WasmCretonneCompile.cpp
new file mode 100644
--- /dev/null
+++ b/js/src/wasm/WasmCretonneCompile.cpp
@@ -0,0 +1,277 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ * vim: set ts=8 sts=4 et sw=4 tw=99:
+ *
+ * Copyright 2017 Mozilla Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "wasm/WasmCretonneCompile.h"
+
+extern "C" {
+// The API exported from this module to Rust.
+#include "baldrdash/baldrapi.h"
+}
+
+extern "C" {
+// The entry point exported from Rust.
+bool wasm_compile_function(const BD_WasmContext*);
+}
+
+// The context presented to Rust.  It is opaque to Rust (an ADT); Rust accesses
+// the fields of this structure through accessors, defined below.
+
+struct WasmContext
+{
+    CompileTask* task;
+    const FuncBytes* func;
+    FuncOffsets offsets;
+};
+
+bool
+wasm::CretonneCompileFunction(CompileTask* task, FuncCompileUnit* unit, UniqueChars* error)
+{
+    MOZ_ASSERT(task->tier() == Tier::Ion);
+
+    WasmContext cx;
+    cx.task = task;
+    cx.func = &unit->func();
+
+    if (!wasm_compile_function(reinterpret_cast<const BD_WasmContext*>(&cx)))
+        return false;
+
+    unit->finish(cx.offsets);
+
+    return true;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+//
+// Callbacks from Rust to C++.  These don't actually have to be named functions;
+// they could be members (function pointers) on the WasmContext structure.  But
+// there doesn't seem to be any harm in naming them.
+
+// Assert that we got the values right when we defined the API for Rust
+
+static_assert(BD_ValType::ValType_I32 == static_cast<int>(wasm::ValType::I32), "Failed constraint");
+static_assert(BD_ValType::ValType_I64 == static_cast<int>(wasm::ValType::I64), "Failed constraint");
+static_assert(BD_ValType::ValType_F32 == static_cast<int>(wasm::ValType::F32), "Failed constraint");
+static_assert(BD_ValType::ValType_F64 == static_cast<int>(wasm::ValType::F64), "Failed constraint");
+
+static_assert(BD_ExprType::ExprType_I32 == static_cast<int>(wasm::ExprType::I32), "Failed constraint");
+static_assert(BD_ExprType::ExprType_I64 == static_cast<int>(wasm::ExprType::I64), "Failed constraint");
+static_assert(BD_ExprType::ExprType_F32 == static_cast<int>(wasm::ExprType::F32), "Failed constraint");
+static_assert(BD_ExprType::ExprType_F64 == static_cast<int>(wasm::ExprType::F64), "Failed constraint");
+static_assert(BD_ExprType::ExprType_Void == static_cast<int>(wasm::ExprType::Void), "Failed constraint");
+
+static_assert(BD_MemoryUsage::MemoryUsage_None == static_cast<int>(wasm::MemoryUsage::None), "Failed constraint");
+static_assert(BD_MemoryUsage::MemoryUsage_Unshared == static_cast<int>(wasm::MemoryUsage::Unshared), "Failed constraint");
+static_assert(BD_MemoryUsage::MemoryUsage_Shared == static_cast<int>(wasm::MemoryUsage::Shared), "Failed constraint");
+
+static_assert(BD_SigIdDescKind::SigIdDesc_Kind_None == static_cast<int>(wasm::SigIdDesc::Kind::None), "Failed constraint");
+static_assert(BD_SigIdDescKind::SigIdDesc_Kind_Immediate == static_cast<int>(wasm::SigIdDesc::Kind::Immediate), "Failed constraint");
+static_assert(BD_SigIdDescKind::SigIdDesc_Kind_Global == static_cast<int>(wasm::SigIdDesc::Kind::Global), "Failed constraint");
+
+// WasmContext
+
+const BD_ModuleEnvironment*
+cx_environment(const BD_WasmContext* cx_)
+{
+    const WasmContext* cx = reinterpret_cast<const WasmContext*>(cx_);
+    const ModuleEnvironment* env = &cx->task->env();
+    return reinterpret_cast<const BD_ModuleEnvironment*>(env);
+}
+
+// ModuleEnvironment
+
+const BD_Sig*
+env_functionSignature(const BD_ModuleEnvironment* env_, uint32_t funcIndex)
+{
+    const wasm::ModuleEnvironment* env = reinterpret_cast<const wasm::ModuleEnvironment*>(env_);
+    const Sig* sig = env->funcSigs[funcIndex];
+    return reinterpret_cast<const BD_Sig*>(sig);
+}
+
+uint32_t
+env_funcImportGlobalDataOffset(const BD_ModuleEnvironment* env_, uint32_t funcIndex)
+{
+    const wasm::ModuleEnvironment* env = reinterpret_cast<const wasm::ModuleEnvironment*>(env_);
+    return env->funcImportGlobalDataOffsets[funcIndex];
+}
+
+bool
+env_funcIsImport(const BD_ModuleEnvironment* env_, uint32_t funcIndex)
+{
+    const wasm::ModuleEnvironment* env = reinterpret_cast<const wasm::ModuleEnvironment*>(env_);
+    return env->funcIsImport(funcIndex);
+}
+
+const BD_SigWithId*
+env_signature(const BD_ModuleEnvironment* env_, uint32_t sigIndex)
+{
+    const wasm::ModuleEnvironment* env = reinterpret_cast<const wasm::ModuleEnvironment*>(env_);
+    const SigWithId* sig = &env->sigs[sigIndex];
+    return reinterpret_cast<const BD_SigWithId*>(sig);
+}
+
+uint32_t
+env_numTables(const BD_ModuleEnvironment* env_)
+{
+    const wasm::ModuleEnvironment* env = reinterpret_cast<const wasm::ModuleEnvironment*>(env_);
+    return env->tables.length();
+}
+
+const BD_TableDesc*
+env_table(const BD_ModuleEnvironment* env_, uint32_t tableIndex)
+{
+    const wasm::ModuleEnvironment* env = reinterpret_cast<const wasm::ModuleEnvironment*>(env_);
+    const TableDesc* table = &env->tables[0];
+    return reinterpret_cast<const BD_TableDesc*>(table);
+}
+
+const BD_GlobalDesc*
+env_global(const BD_ModuleEnvironment* env_, uint32_t globalIndex)
+{
+    const wasm::ModuleEnvironment* env = reinterpret_cast<const wasm::ModuleEnvironment*>(env_);
+    const GlobalDesc* global = &env->globals[globalIndex];
+    return reinterpret_cast<const BD_GlobalDesc*>(global);
+}
+
+uint32_t
+env_minMemoryLength(const BD_ModuleEnvironment* env_)
+{
+    const wasm::ModuleEnvironment* env = reinterpret_cast<const wasm::ModuleEnvironment*>(env_);
+    return env->minMemoryLength;
+}
+
+bool
+env_hasMaxMemoryLength(const BD_ModuleEnvironment* env_)
+{
+    const wasm::ModuleEnvironment* env = reinterpret_cast<const wasm::ModuleEnvironment*>(env_);
+    return env->maxMemoryLength.isSome();
+}
+
+uint32_t
+env_maxMemoryLength(const BD_ModuleEnvironment* env_)
+{
+    const wasm::ModuleEnvironment* env = reinterpret_cast<const wasm::ModuleEnvironment*>(env_);
+    if (env->maxMemoryLength.isSome())
+        return env->maxMemoryLength.value();
+    return 0;
+}
+
+BD_MemoryUsage
+env_memoryUsage(const BD_ModuleEnvironment* env_)
+{
+    const wasm::ModuleEnvironment* env = reinterpret_cast<const wasm::ModuleEnvironment*>(env_);
+    MemoryUsage mu = env->memoryUsage;
+    return BD_MemoryUsage(static_cast<int>(mu));
+}
+
+// Sig
+
+uint32_t
+sig_length(const BD_Sig* sig_)
+{
+    const Sig* sig = reinterpret_cast<const Sig*>(sig_);
+    return sig->args().length();
+}
+
+const BD_ValType*
+sig_args(const BD_Sig* sig_)
+{
+    const Sig* sig = reinterpret_cast<const Sig*>(sig_);
+    const ValType* args = &sig->args()[0];
+    return reinterpret_cast<const BD_ValType*>(args);
+}
+
+BD_ValType
+sig_argType(const BD_Sig* sig_, uint32_t argIndex)
+{
+    const Sig* sig = reinterpret_cast<const Sig*>(sig_);
+    ValType type = sig->args()[argIndex];
+    return BD_ValType(int(type));
+}
+
+BD_ExprType
+sig_retType(const BD_Sig* sig_)
+{
+    const Sig* sig = reinterpret_cast<const Sig*>(sig_);
+    ExprType ret = sig->ret();
+    return BD_ExprType(int(ret));
+}
+
+// SigWithId
+
+const BD_SigIdDesc*
+sigWithId_idDesc(const BD_SigWithId* sig_)
+{
+    const SigWithId* sig = reinterpret_cast<const SigWithId*>(sig_);
+    const SigIdDesc* sigId = &sig->id;
+    return reinterpret_cast<const BD_SigIdDesc*>(sigId);
+}
+
+// SigIdDesc
+
+BD_SigIdDescKind
+sigIdDesc_kind(const BD_SigIdDesc* desc_)
+{
+    const SigIdDesc* desc = reinterpret_cast<const SigIdDesc*>(desc_);
+    SigIdDesc::Kind kind = desc->kind();
+    return BD_SigIdDescKind(int(kind));
+}
+
+// Global
+
+bool
+global_isConstant(const BD_GlobalDesc* global_)
+{
+    const GlobalDesc* global = reinterpret_cast<const GlobalDesc*>(global_);
+    return global->isConstant();
+}
+
+BD_ConstantValue
+global_constantValue(const BD_GlobalDesc* global_)
+{
+    const GlobalDesc* global = reinterpret_cast<const GlobalDesc*>(global_);
+    Val value = global->constantValue();
+    BD_ConstantValue v;
+    v.t = BD_ValType(int(value.type()));
+    switch (value.type()) {
+      case ValType::I32:
+        v.u.i32 = value.i32();
+        break;
+      case ValType::I64:
+        v.u.i64 = value.i64();
+        break;
+      case ValType::F32:
+        v.u.f32 = value.f32();
+        break;
+      case ValType::F64:
+        v.u.i64 = value.i64();
+        break;
+      default:
+        MOZ_CRASH("Bad type");
+    }
+    return v;
+}
+
+BD_ValType
+global_type(const BD_GlobalDesc* global_)
+{
+    const GlobalDesc* global = reinterpret_cast<const GlobalDesc*>(global_);
+    ValType type = global->type();
+    return BD_ValType(int(type));
+}
+
+
diff --git a/js/src/wasm/WasmCretonneCompile.h b/js/src/wasm/WasmCretonneCompile.h
new file mode 100644
--- /dev/null
+++ b/js/src/wasm/WasmCretonneCompile.h
@@ -0,0 +1,39 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ * vim: set ts=8 sts=4 et sw=4 tw=99:
+ *
+ * Copyright 2017 Mozilla Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef wasm_cretonne_compile_h
+#define wasm_cretonne_compile_h
+
+#include "mozilla/Attributes.h"
+
+#include "wasm/WasmTypes.h"
+
+namespace js {
+namespace wasm {
+
+class CompileTask;
+class FuncCompileUnit;
+
+// Generates very fast code at the expense of compilation time.
+MOZ_MUST_USE bool
+CretonneCompileFunction(CompileTask* task, FuncCompileUnit* unit, UniqueChars* error);
+
+} // namespace wasm
+} // namespace js
+
+#endif // wasm_cretonne_compile_h
diff --git a/js/src/wasm/WasmGenerator.cpp b/js/src/wasm/WasmGenerator.cpp
--- a/js/src/wasm/WasmGenerator.cpp
+++ b/js/src/wasm/WasmGenerator.cpp
@@ -21,16 +21,17 @@
 #include "mozilla/CheckedInt.h"
 #include "mozilla/EnumeratedRange.h"
 #include "mozilla/SHA1.h"
 
 #include <algorithm>
 
 #include "wasm/WasmBaselineCompile.h"
 #include "wasm/WasmCompile.h"
+#include "wasm/WasmCretonneCompile.h"
 #include "wasm/WasmIonCompile.h"
 #include "wasm/WasmStubs.h"
 
 #include "jit/MacroAssembler-inl.h"
 
 using namespace js;
 using namespace js::jit;
 using namespace js::wasm;
@@ -43,16 +44,17 @@ using mozilla::MakeEnumeratedRange;
 
 static const unsigned GENERATOR_LIFO_DEFAULT_CHUNK_SIZE = 4 * 1024;
 static const unsigned COMPILATION_LIFO_DEFAULT_CHUNK_SIZE = 64 * 1024;
 static const uint32_t BAD_CODE_RANGE = UINT32_MAX;
 
 ModuleGenerator::ModuleGenerator(UniqueChars* error)
   : tier_(Tier(-1)),
     error_(error),
+    cretonneEnabled_(false),
     linkDataTier_(nullptr),
     metadataTier_(nullptr),
     numSigs_(0),
     numTables_(0),
     lifo_(GENERATOR_LIFO_DEFAULT_CHUNK_SIZE),
     masmAlloc_(&lifo_),
     masm_(MacroAssembler::WasmToken(), masmAlloc_),
     lastPatchedCallsite_(0),
@@ -139,19 +141,23 @@ ModuleGenerator::initAsmJS(Metadata* asm
 
 bool
 ModuleGenerator::initWasm(const CompileArgs& args)
 {
     MOZ_ASSERT(!env_->isAsmJS());
 
     bool canBaseline = BaselineCanCompile();
     bool debugEnabled = args.debugEnabled && canBaseline;
+
+    // We use Tier::Ion also for Cretonne; we decide later about which compiler
+    // to use.
     tier_ = ((args.alwaysBaseline || debugEnabled) && canBaseline)
             ? Tier::Baseline
             : Tier::Ion;
+    cretonneEnabled_ = args.alwaysCretonne;
 
     if (!linkData_.initTier(tier_))
         return false;
     linkDataTier_ = &linkData_.linkData(tier_);
 
     auto metadataTier = js::MakeUnique<MetadataTier>(tier_);
     if (!metadataTier)
         return false;
@@ -958,16 +964,17 @@ ModuleGenerator::startFuncDef(uint32_t l
 }
 
 bool
 ModuleGenerator::launchBatchCompile()
 {
     MOZ_ASSERT(currentTask_);
 
     currentTask_->setDebugEnabled(metadata_->debugEnabled);
+    currentTask_->setCretonneEnabled(cretonneEnabled_);
 
     size_t numBatchedFuncs = currentTask_->units().length();
     MOZ_ASSERT(numBatchedFuncs);
 
     if (parallel_) {
         if (!StartOffThreadWasmCompile(currentTask_))
             return false;
         outstanding_++;
@@ -1249,18 +1256,23 @@ bool
 wasm::CompileFunction(CompileTask* task, UniqueChars* error)
 {
     TraceLoggerThread* logger = TraceLoggerForCurrentThread();
     AutoTraceLog logCompile(logger, TraceLogger_WasmCompilation);
 
     switch (task->tier()) {
       case Tier::Ion:
         for (FuncCompileUnit& unit : task->units()) {
-            if (!IonCompileFunction(task, &unit, error))
-                return false;
+            if (task->cretonneEnabled()) {
+                if (!CretonneCompileFunction(task, &unit, error))
+                    return false;
+            } else {
+                if (!IonCompileFunction(task, &unit, error))
+                    return false;
+            }
         }
         break;
       case Tier::Baseline:
         for (FuncCompileUnit& unit : task->units()) {
             if (!BaselineCompileFunction(task, &unit, error))
                 return false;
         }
         break;
diff --git a/js/src/wasm/WasmGenerator.h b/js/src/wasm/WasmGenerator.h
--- a/js/src/wasm/WasmGenerator.h
+++ b/js/src/wasm/WasmGenerator.h
@@ -132,24 +132,26 @@ class CompileTask
 {
     const ModuleEnvironment&   env_;
     Tier                       tier_;
     LifoAlloc                  lifo_;
     Maybe<jit::TempAllocator>  alloc_;
     Maybe<jit::MacroAssembler> masm_;
     FuncCompileUnitVector      units_;
     bool                       debugEnabled_;
+    bool                       cretonneEnabled_;
 
     CompileTask(const CompileTask&) = delete;
     CompileTask& operator=(const CompileTask&) = delete;
 
     void init() {
         alloc_.emplace(&lifo_);
         masm_.emplace(jit::MacroAssembler::WasmToken(), *alloc_);
         debugEnabled_ = false;
+        cretonneEnabled_ = false;
     }
 
   public:
     CompileTask(const ModuleEnvironment& env, Tier tier, size_t defaultChunkSize)
       : env_(env),
         tier_(tier),
         lifo_(defaultChunkSize)
     {
@@ -175,16 +177,22 @@ class CompileTask
         return tier_;
     }
     bool debugEnabled() const {
         return debugEnabled_;
     }
     void setDebugEnabled(bool enabled) {
         debugEnabled_ = enabled;
     }
+    bool cretonneEnabled() const {
+        return cretonneEnabled_;
+    }
+    void setCretonneEnabled(bool enabled) {
+        cretonneEnabled_ = enabled;
+    }
     bool reset(UniqueFuncBytesVector* freeFuncBytes) {
         for (FuncCompileUnit& unit : units_) {
             if (!freeFuncBytes->emplaceBack(Move(unit.recycle())))
                 return false;
         }
 
         units_.clear();
         masm_.reset();
@@ -207,16 +215,17 @@ class MOZ_STACK_CLASS ModuleGenerator
     typedef HashSet<uint32_t, DefaultHasher<uint32_t>, SystemAllocPolicy> Uint32Set;
     typedef Vector<CompileTask, 0, SystemAllocPolicy> CompileTaskVector;
     typedef Vector<CompileTask*, 0, SystemAllocPolicy> CompileTaskPtrVector;
     typedef EnumeratedArray<Trap, Trap::Limit, CallableOffsets> TrapExitOffsetArray;
 
     // Constant parameters
     Tier                            tier_;
     UniqueChars*                    error_;
+    bool                            cretonneEnabled_;
 
     // Data that is moved into the result of finish()
     Assumptions                     assumptions_;
     LinkDataTier*                   linkDataTier_; // Owned by linkData_
     LinkData                        linkData_;
     MetadataTier*                   metadataTier_; // Owned by metadata_
     MutableMetadata                 metadata_;
 
